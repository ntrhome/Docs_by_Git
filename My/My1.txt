GoogleDrive for Android:
https://drive.google.com/drive/folders/1tYtB_p0UWaavxAA2JjBZ-PW0SVlm5Q16
=================
Простое переключение на другой экран:
http://developer.alexanderklimov.ru/android/activity.php
=================
Documentation API:
https://developer.android.com/reference/android/widget/TextView.html#attr_android:inputType
=================
Цвета:
http://www.google.com/design/spec/style/color.html# ->
https://material.io/design/color/#
=================
Android Studio
http://qaru.site/questions/212/why-is-the-android-emulator-so-slow-how-can-we-speed-up-the-android-emulator
	http://qaru.site/questions/2194744/androidios-peer-to-peer-architecture (-> https://developers.google.com/nearby/messages/overview)
=================
Genymotion
http://v-androide.com/obzory/emuljatory-obzory/genymotion-kak-ispolzovat-emulyator.html

=================Java - литералы:
Литералы числовые:
(_ - игнорируется, но нельзя первым или последним)
десят.		999_999___999
восьмеричный 	09 (ошибка)
шестнадцат	0x9AF0_7EC7
двоичн.		0b10110 //int х = 0x0101_0101_0001_1010;
long		...L
float		...F
double		...D
действит.	по умолч. литерал переводится в double, 
			- десятич. форма: 4.0, 
			- десятич. экспоненциальная (E - степень 10ки): 4e5 = 4*10^5, 5e-7, 6e+8
			- шестнадцатирич. (P - степень 2ки): 0x12p4 = 0x12*2^4
Литералы логические:
boolean		только два:	true (!=0) и false (=0)

Литералы символьные:
char		один Unicode-символ в одинарных кавычках - 'a', 
		экранированные спецсимволы '\'', '\\', '\n', '\r'-возврат каретки, '\b'-забой, '\f'-подача страницы, '\t'-табуляция
		по коду в восьмиричной форме ('\[3]'): '\141',
		по коду в шестнадцатиричной форме ('\u[4]'): '\u006F'

Литералы строковые:
String		"two\ nlines ", " \"This is in double quotes\"" -работают экранированные символы, и - все в одной строке (механизма переноса нет)
=================Java - битовые операции:
Операции сдвига влево / вправо выдвигают биты за пределы типа с их утерей.
Обычный сдвиг вправо (>>) восстанавливает (у знаковых) знаковый бит, отсюда происходит расширение знака, отсюда сдвиг вправо минус единицы - всегда минус единица, также сдвиг вправо на k разрядов это деление на 2^k с отбрасыванием остатка). Есть специальный беззнаковый сдвиг вправо (>>>) - знаковый бит обрабатывается как обычный (без восстановления и расширения - заполняется нулями слева).
Сдвиг влево (<<) вдвигает в знаковый бит очередной бит справа.
Однако нужно помнить об автоматическом "продвижении" типов в Java, с учетом этого в выражениях результат сдвига часто непредвидим.
=================Java - Методы:
Параметры входят в область видимости метода и работают аналогично объявленным переменным.
Методы могут возвращать результатом встроенные примитивные массивы.
=================Java - приведение типов:
Расширяющее приведение ("продвижение") выполняется автоматически (и могжет давать непредсказуемые результаты при счислении, когда расчет на величину типа, например при поразрядном сдвиге), сужающие - явно:
int i; 
byte b = (byte) i; //будет сведено к результату ДЕЛЕНИЯ ПО МОДУЛЮ (остатку от целочисленного деления) на диапазон типа byte.
float f;
i = (int) f; //усечение дробной части + ДЕЛЕНИЕ ПО МОДУЛЮ (остаток) на диапазон int.

=================Java - массив:
Массивы (встроенные в Java) существуют только для примитивных типов. 
И методы могут возвращать их в качестве результата.
Память под массивы выделяется динамически.
int month_days[];		- декларация (память не выделена)
int[] month_days, a, b;		- то же самое но всех указанных переменных (в отличие от С-? декларируются 3 массива)
month_days = new int[12];	- дефинация (выделение памяти)
   или
int month_days[] = new int[l2];
   или с инициализацией:
int month_days[] = {31,28,31,30,31,30,31,31,30,31,30,31};
Ситуацию unbound java отслеживает.
Многомерный массив - это массив массивов массивов массивов массивов...
int twoD[][] = new int[4][5]; - четыре одномерных массива по пять элементов каждый.
int three[][][] = new int[3][4][5]; - масив из трех массивов, каждый из которых - одномерный массив на 5 элементов.

При резервировании памяти для многомерного массива необходимо указать размер только для первого (левого) индекса (если нет инициализации), остальную размерность можно задавать поуровнево - от левого индекса к правому. 
int a[][][][] = new int [3][][][]; //пример too long
Причем !!! эта размерность может быть различной для каждого уровня (на примере с инициализацией):
int[][][] a = {	{{1,2},{3,4,5},{6,7}},
                {{1,2}              },
                {{1,2},{3,4,5,6}    } };


=================Java - строки:
Строки - не примитивный тип и не их массивы.
Строка это объект класса String.
=================Java - двоичная форма:
7654 3210
0010 1010 = 2^5 + 2^3 + 2^1 = 32 + 8 + 2 = 42 (byte)
Все (кроме char) - со знаком.

Отрицательные числа представлены в дополнительном коде, получаемом путем инвертирования (изменения 1 на О, и наоборот) всех двоичных разрядов
исходного значения с последующим добавлением 1 к результату. Например, число 
-42 = ~(42)+1 = ~(0b0010_1010) + 1 = 0b1101_0101 + 1 = 0b1101_0110 = -42.
Положительное число из отрицательного получается абсолютно тем же путем (инвертируем и добавляем 1):
42 = ~(-42)+1 = ~(0b1101_0110) + 1 = 0b0010_1001 + 1 = 0b0010_1010 = 42.
При этом самый левый бит естественным образом становится для числа знаковым разрядом (что не следует забывать пользуясь операторами поразрадного сдвига).

Причина, по которой применяется дополнительный код, становится понятной при рассмотрении процесса перехода церез нуль. Если речь идет о значении типа byte, то нуль представлен значением 0b0000_0000. Обратное его значение, получаемое через инверсию есть 0b11111111, которое по логике есть отрицательный нуль, но чего в математике быть не может. Выходом из этого затруднения и служит дополнительный код, в котором к обратному значению добавляется 1 и получается двоичное значение 0b1_0000_0000. Но старший единичный разряд оказывается сдвинутым влево слишком далеко, чтобы уместиться в byte, и поэтому теряется. Остается общее значение 0: 0b0000_0000. В то же время значение 0b1111_1111 - это двоичный код -1, и т.д.


123










=================





