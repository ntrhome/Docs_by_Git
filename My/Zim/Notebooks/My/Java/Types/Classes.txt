Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-06-16T19:34:49+03:00

====== Classes ======
Created Воскресенье 16 июня 2019

**Класс - это сложный тип, содержащий члены - свойства и методы **(в джавке называемый еще шаблоном объекта).

**Объект - реализованный в памяти экземпляр класса.**
Класс это логический каркас, определяющий взаимосвязь между его членами, а объект - это его физическая сущность, занимающая конкретный кусок памяти.

**Создание объекта** - двуэтапно: 
- декларация имени (ссылка на объект, начальное значение для типа =null),
- дефинация объекта (динамическая, через new - резервирует память, возвращает ссылку - дескриптор объекта в памяти):
		Box x /*=null*/; x = new Box();	
		Box x = new Box(); //можно объеденить
Если new неудачно, то исключение времени выполнения.
Имя класса со скобками в "new Box()" означает команду вызова **конструктора **класса, в скобках могут быть аргументы для конструктора.

**Присваивание ссылок - создание копии ссылки (не объекта):** 
когда мы присваиваем ссылке на объект ссылку на объект, то мы оперируем сугубо ссылками, без копирования объекта:
		Box x = new Box();
		Box y = x; //"y" и "x" ссылаются на один и тот же объект.
		Box x = null; //разрывает связь ссылки с объектом (теперь доступ к объекту сохранился только у "y"), но объект существует пока на него есть хоть одна действующая ссылка.

**getClass().getName()** - иногда в коде нужно получить имя текущего класса. Для этого есть специальные методы getClass().getName() и другие родственные методы.		

**Правило доступности членов по ссылке в иерархии наследования, а также их версии перегрузки-перекрытия:**
	1. В рамках иерархии классов [1..N] любой ссылке K∈[1..N] можно присвоить любой объект-наследник (из диапазона [K..N]), но не объект-потомок (из диапазона [1..K)).
	2. Через такую ссылку K доступны только те члены и в том состоянии перекрытия-перегрузки, которые определены-наследованы на уровне K.

				//1:228-1 "Следует иметь в виду, что доступные члены класса определяются типом ссылоч­ной переменной, а не типом объекта, на который она ссылается. Это означает, что если ссылочной переменной из суперкласса присваивается ссылка на объект под­класса, то доступ предоставляется только к указанным в ней частям объекта, опре­деляемого в суперклассе. ... Это становится понятным по зрелом размышлении, ведь суперклассу неизвестно, что//
				//именно добавляет в него подкласс."//
				
				Из текущего класса через ссылку this можно гарантировано обратиться к члену текущего класса (применяется при взаимных вызовах между объектами; иногда применяется при перекрытии члена кодом текущего класса, но это поганый стиль).

				Из текущего класса через ссылку super можно обратиться к члену его непосредственного суперкласса (например, перекрываемому членом текущего подкласса: suреr.скрытый_член).
				Из текущего класса через метод super(аргументы) можно вызвать конструктор непосредственного суперкласса (применяется для инициации дерева иерархии). Вызов метода super() делается только в первом операторе конструктора субкласса. Сюда же крайне полезна фишка с передачей производного объекта по ссылке суперобъекта - так организовывается, например, копирующий конструктор:
class A           
{int a; A(int i              ){           a=i;} A(A o){          a=o.a;}}
class B extends A 
{int b; B(int i, int j       ){super(i);  b=j;} B(B o){super(o); b=o.b;}}
class C extends B 
{int c; C(int i, int j, int k){super(i,j);c=k;} C(C o){super(o); c=o.c;}}
...
C c = new C(5,6,8);
C copy = new C(c); //o будучи C идет вверх по иерархии как (B o), (A o)

__= = = = = = = = = = = = = = = доработать:__

**Порядок инициализации объекта (доработать):**
		1. создаются члены:
				- поля (пока без инициализации, если таковая есть - содержат начальные значения для типа),
				- методы;
		2. последовательная инициализация полей (слева направо, сверху вниз), причем если при инициализации текущего поля обратиться (в методе) к следующему по порядку полю, то следующее опять же еще не проинициализированно и содержит начальное для типа значение;
		3. работает конструктор.

(Порядок инициализации объекта при наследовании классов, см. в [[Types:Classes:extends]]).

**Порядок инициализации наследованного (Н:) объекта (доработать):**
	Циклично для каждого уровня наследования, с учетом следующих моментов перегрузки и перекрытия:

		1. создаются члены:
						- поля (пока без инициализации, если таковая есть - содержат начальные значения для типа),
						- методы, __Н: сразу перегруженные наследными классами, если таковое есть__;
		2. последовательная инициализация полей:
				- слева направо, сверху вниз, 
				- причем если при инициализации текущего поля обратиться (с помощью метода) к следующему по порядку полю, то следующее опять же еще не проинициализированно и содержит начальное для типа значение;
		3. работает конструктор.

