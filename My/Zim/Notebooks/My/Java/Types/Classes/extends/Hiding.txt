Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-07-01T10:59:18+03:00

====== Hiding ======
Created понеділок 01 липень 2019

**Hiding - переопределение (перекрытие, скрытие) члена:**
Если в иерархии классов у субкласса и суперкласса члены совпадают (имена и сигнатуры), то говорят, что член субкласса переопределяет (перекрывает, склывает) член суперкласса. 
(Если совпадает только имя метода, то метод перегружается - см. [[Classes:Methods:Overload]]).

Переопределение применяется для специализации класса.

- - - - - - - - - - - - - 

**Сюда же в Hiding - Динамическая диспетчеризация методов:**
- механизм, с помощью которого вызов переопределенного метода разрешается во время выполнения, а не компиляции (объекты создаются во время выполнения, следовательно требуется динамическая диспетчеризация методов).

- - - - - - - - - - - - - 

**Правило доступности членов по ссылке в иерархии наследования с учетом переопределения:**
	1) В рамках иерархии классов [1..N] любой ссылке типа K∈[1..N] можно присвоить любой объект-потомок P из диапазона [K..N], но не объект-предок из диапазона [1..K).
	2) ~~Однако такой ссылке K доступны только те члены и в том состоянии переопределения, что определены-наследованы на уровне K. ~~Такой ссылке K доступны члены:
		- только те, что определены-наследованы на уровне K (т.е. известный на уровне типа ссылки);
		- в том состоянии переопределения, которое определено-переопределено на уровне P (т.е. известном на уровне типа объекта).

				//1:228-1 "Следует иметь ввиду, что //**доступные члены класса определяются типом ссылоч­ной переменной, а не типом объекта, на который она ссылается**//. Это означает, что если ссылочной переменной суперкласса присваивается ссылка на объект суб­класса, то доступ предоставляется только к тем частям объекта, которые определены в суперклассе. ... Это становится понятным по зрелом размышлении, ведь суперклассу неизвестно, что именно добавляет в него подкласс."//
				
1:240-2 "Иначе говоря, вариант переопределенного метода выбирается для выполнения в зависимости от типа объекта, на который делается ссылка, а не типа ссылочной переменной. Так, если суперкласс содержит метод, переопределяемый в подклассе, то по ссылке на разные типы объектов через ссылочную переменную из суперкласса будут выполняться разные варианты этого метода."

				Из текущего класса через ссылку this можно гарантировано обратиться к члену текущего класса (применяется при взаимных вызовах между объектами; иногда применяется при перекрытии члена кодом текущего класса, но это поганый стиль).

				Из текущего класса через ссылку super можно обратиться к члену его непосредственного суперкласса (например, перекрываемому членом текущего подкласса: suреr.скрытый_член).
				Из текущего класса через метод super(аргументы) можно вызвать конструктор непосредственного суперкласса (применяется для инициации дерева иерархии). Вызов метода super() делается только в первом операторе конструктора субкласса. Сюда же крайне полезна фишка с передачей производного объекта по ссылке суперобъекта - так организовывается, например, копирующий конструктор:
class A           
{int a; A(int i              ){           a=i;} A(A o){          a=o.a;}}
class B extends A 
{int b; B(int i, int j       ){super(i);  b=j;} B(B o){super(o); b=o.b;}}
class C extends B 
{int c; C(int i, int j, int k){super(i,j);c=k;} C(C o){super(o); c=o.c;}}
...
C c = new C(5,6,8);
C copy = new C(c); //o будучи C идет вверх по иерархии как (B o), (A o)

- - - - - - - - - - - - - 

Если в процессе наследования переопределялись поля класса, то на каждом уровне иерархии, где эти поля определялись-переопределялись, будет создан свой экземпляр этих полей, и у них если есть, то собственная инициализация. К таким собственным экземплярам полей суперкласса можно доступиться из непосредственного субкласса через super.member.

- - - - - - - - - - - - - 

= = = = = = = = = = = = = = = = = = = = = 
= = = = = = = = = = = = = = = = = = = = = 


