Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-06-29T01:44:15+03:00

====== extends ======
Created Суббота 29 июня 2019

**Наследование (inheritance), extends**

В терминологии джавки:
- наследуемый, исходный, родительский класс - суперкласс (superclass), а
- наследующий, производный, порожденный - субкласс (subclass).
Понимаем так: суперкласс - более широкое понятие - "человек", а субкласс - более узкое, специализированное, с заморочками - "женщина".

Субкласс наследует все члены суперкласса, добавляя к ним собственные, специализированные элементы.

Субкласс - специализированный суперкласс.

Субкласс - принципиально - обычный класс, и также может выступить суперклассом для другого субкласса.

Для каждого создаваемого подкласса можно указать только один суперкласс.
(Чего нельзя в джавке, так это построить субкласс на базе сразу нескольких суперклассов - "множественное наследование" - можно только на бозе одного.)

- - - - - - - - - - - - - 

class Superclass 		  { int i=1, j=2;  }//если не private
class Subclass **extends** Superclass { int k = i + j; }//то простой доступ

- - - - - - - - - - - - - 

**Доступ:**
Субкласс имеет такой доступ к членам суперкласса с модификатором:
- public 	- свободный (у наследника останется public);
- protected 	- свободный (у наследника станет private);
- private	- нет доступа. 
								Член класса, объявленый приватным, недоступен для любого кода вне своего класса, в том числе и для субклассов.

- - - - - - - - - - - - - 
**Ссылки (архиважно, сюда еще super и this):**
Переменной типа суперкласс МОЖНО присвоить ссылку на субкласс (__любого поколения наследования?__), однако с ограничением: через такую ссылку будет возможно доступиться только к тем членам субкласса, которые существуют в суперклассе (т.е. без приобретенной субклассом специализации).
К КАКИМ ЧЛЕНАМ ИМЕЕТ ДОСТУП ССЫЛКА, КОГДА ОНА ССЫЛАЕТСЯ НА СУПЕРКЛАСС И КОГДА НА СУБКЛАСС:
**То есть, доступность члена класса определяется типом ссылоч­ной переменной, а не типом объекта, на который она ссылается.**
Потому как суперклассу неизвестно, что добавляет в него субкласс.

И ця штука обратно не работает, т.е. переменной типа субкласс нельзя присвоить объект суперкласса.

Но! Есть второй
- - - - - - - - - - - - - 

**Порядок вызова конструкторов в наследственных классах:**
Две вещи:
		- при конструировании объекта сначала вызываются конструкторы суперклассов (**СВЕРХУ ВНИЗ** по иерархии) а затем конструктор текущего субкласса, завершая формирование объекта;
		- конструктор каждого класса в иерархии вызывается **ВСЕГДА** - неявно (дефаултный или если есть ручной без параметров) или явно ручной (без или с параметрами) через super.

class Cmd0
{
	public static void main(String[] args) { var c = new **Cmd3**();}
	Cmd0(){System.out.println("Cmd0");}
}
class Cmd1 extends Cmd0{	Cmd1(){System.out.println("Cmd1");}}
class Cmd2 extends Cmd1{	Cmd2(){System.out.println("Cmd2");}}
class Cmd3 extends Cmd2{	Cmd3(){System.out.println("Cmd3");}}
>
Cmd0
Cmd1
Cmd2
Cmd3

- - - - - - - - - - - - - 
**Hiding - переопределение (перекрытие, скрытие) члена:**
Если в иерархии классов у субкласса и суперкласса члены совпадают (имена и сигнатуры), то говорят, что член субкласса переопределяет член суперкласса. (Если совпадает только имя метода, то метод перегружается - см. [[Classes:Methods:Overload]]).

Когда переопределенный член вызывается из своего класса, он ссылается на свой вариант, а вариант члена суперкласса будет скрыт.

Переопределение полезно, поскольку от суперкласса к субклассу возможности класса растут, следовательно и оперирование классом меняется ("вывести все свойства" - их стало больше).

**(сюда еще super и this:** super.член - доступ к члену суперкласса, this.член - явно указанный доступ к члену текущего класса**).**

- - - - - - - - - - - - - 

**Сюда же в Hiding - Динамическая диспетчеризация методов:**
механизм, с помощью которого вызов переопределенного метода разрешается во время выполнения, а не компиляции (объекты создаются во время выполнения, следовательно требуется динамическая диспетчеризация методов).

Суть проявляется при юзании ссылок (см. "Ссылки" здесь выше), и она следующая:
есть Суперкласс и Субкласс, далее:
- объявили переменную Суперкласса, присвоили ей объект Субкласса - оперирует с членом Суперкласса (бо переменная Суперкласса);
- объявили переменную Субкласса, присвоили ей объект Субкласса - оперирует с членом Субкласса (бо переменная Субкласса);
- объявили переменную Субкласса, присвоили ей объект Суперкласса - ошибка (бо нельзя) - см. "Ссылки" выше.

Пример:
class Cmd0
{
	public static void main(String[] args) 
	{
		var sup = new Super();
		var sub = new Sub();
		Super s1 = sub;
		Sub   s2 = sub;
		System.out.println(s1.i + "   " + s2.i);
	}
}
class Super {int i=9;}
class Sub extends Super{int i=888;}
>
9   888
- - - - - - - - - - - - - 







= = = = = = = = = = = = = = = = = = = = = 

