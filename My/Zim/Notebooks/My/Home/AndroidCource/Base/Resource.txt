Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-06-25T16:31:01+03:00

====== Resource ======
Created вівторок 25 червень 2019

(25.doc)

В Android принято держать некоторые объекты - изображения, строковые константы, цвета, анимацию, стили и т.п. за пределами исходного кода. Система поддерживает хранение ресурсов в отдельных файлах. Ресурсы легче поддерживать, обновлять, редактировать.

Каждое приложение на Android содержит каталог для ресурсов res и каталог для активов assets. Реальное различие между ресурсами и активами заключается в следующем:
 - информация в каталоге ресурсов будет доступна в приложении через класс R, который автоматически генерируется средой разработки. То есть хранение файлов и данных в ресурсах (в каталоге res) делает их легкодоступными для использования в коде программы;
 - для чтения информации, помещенной в каталог активов assets (необработанный формат файла), необходимо использовать AssetManager для чтения файла как потока байтов.

Имена файлов для ресурсов должны состоять исключительно из букв в нижнем регистре, чисел и символов подчеркивания.
Хотя инструмент синтаксического разбора (parser) ресурсов XML допускает такие имена ресурсов, как hello-string, в файле R.java во время компиляции такое название вызовет ошибку. Для ее устранения можно переименовать ресурс в hello_string, заменив дефис нижним подчеркиванием.
Имена файлов, в которых дублируются базовые имена, вызывают ошибку компиляции (build error). Так происходит со всеми идентификаторами ресурсов, которые сгенерированы для ресурсов, созданных на основе файлов.

Android умеет динамически выбирать данные из дерева ресурсов, содержащие разные значения для разных конфигураций, языков и регионов. При запуске Android автоматически загрузит нужный ресурс, не требуя ни одной строчки кода.

Ресурсы в Android являются декларативными (только чтение?). В основном ресурсы хранятся в виде XML-файлов в каталоге res с подкаталогами values, drawable-ldpi, drawable-mdpi, drawable-hdpi, layout, но также бывают и другие типы ресурсов.

Для удобства система создает идентификаторы ресурсов и использует их в файле R.java (статический класс R, который содержит ссылки на все ресурсы проекта), что позволяет ссылаться на ресурсы внутри кода программы. Статический класс R генерируется автоматически (нет смысла его менять вручную) на основе ваших заданных ресурсов и создается во время компиляции проекта. 

При создании или обновлении файла со строковыми ресурсами среда разработки автоматически создает или обновляет класс R.java, сообщая уникальные ID для определенных в файле строковых ресурсов (Независимо от количества файлов ресурсов, в проекте содержится только один файл R.java). Если открыть данный файл, то можно найти там наши ресурсы в следующем виде:
public static final int hello = 0x7f040000; 
public static final int app_name = 0x7f040001;
В принципе достаточно запомнить, что R.java создает внутренний статический класс как пространство имен, в котором содержатся ID строковых ресурсов. Два static final int, которые используются в переменных hello и app_name, являются идентификаторами ресурсов и соответствуют соответствующим строковым ресурсам. Вы можете использовать данные идентификаторы в своем исходном коде, используя следующий формат - R.string.hello.
Обратите внимание, что сгенерированные ID указывают на int, а не на String. Android при необходимости самостоятельно подставляет вместо int нужные строки.

При изменении только ресурса перекомпиляция не требуется.

Самыми распространенными ресурсами являются, пожалуй, строки (string), цвета (color) и графические рисунки (bitmap). 

В Android используются два подхода - первый подход заключается в том, что ресурсы задаются в файле, при этом имя файла значения не имеет. Второй подход - ресурс задается в виде самого файла, и тогда имя файла уже имеет значение (при этом нужно учитывать определенные нюансы).

Общая структура каталогов, содержащих ресурсы выглядит следующим образом:
	/res/values/strings.xml
			   /colors.xml
			   /dimens.xml
			   /attrs.xml
			   /styles.xml
		/drawable/*.png
				 /*.jpg
				 /*.gif
				 /*.9.png
		/anim/*.xml
		/layout/*.xml
		/raw/*.*
		/xml/*.xml
	/assets/*.*/*.*
В assets может располагаться любой набор подкаталогов разной вложенности. Файлы, находящиеся в любом другом каталоге, размещаются именно на уровне этого каталога и не глубже.

= = = = = = = = = = = = =

Перечисление основных ресурсов Android
	- Цвета - res/values/имя_файла - идентификатор цвета, указывающий на цветовой код. ID таких ресурсов выражаются в R.java как R.color.*. XML-узел: /resources/color
	- Строки - res/values/имя_файла - строковые ресурсы. В их число также входят строки в формате java и html. ID таких ресурсов выражаются в R.java как R.string.*. XML-узел: resources/string. Можно использовать дополнительное форматирование при помощи стандартных html-тегов <b>, <i> и <u>. Методы, которые будут обрабатывать строковые ресурсы с HTML-форматированием, должны уметь обрабатывать эти теги.
	- Меню - /res/menu/имя_файла - меню в приложении можно задать как XML-ресурсы.
	- Параметры - /res/values/имя_файла - Представляет собой параметры или размеры различных элементов. Поддерживает пикселы, дюймы, миллиметры, не зависящие от плотности экрана пикселы (dip) и пикселы, не зависящие от масштаба. ID таких ресурсов выражаются в R.java как R.dimen.*. XML-узел: resources/dimen
	- Изображения - /res/drawable/ваши_файлы - Ресурсы-изображения. Поддерживает форматы JPG, GIF, PNG (самый предпочтительный) и др. Каждое изображение является отдельным файлом и получает собственный идентификатор, который формируется по имени файла без расширения. Такие ID ресурсов представлены в файле R.java как R.drawable.*. Система также поддерживает так называемые растягиваемые изображения (stretchable image), в которых можно менять масштаб отдельных элементов, а другие элементы оставлять без изменений.
	- Отрисовываемые цвета - /res/values/ваш_файл или /res/drawable/ваши_файлы - представляет цветные прямоугольники, которые используются в качетве фона основных отрисовываемых объектов, например точечных рисунков. Поддержка такой функции обеспечивается тегом значения drawable, находящимся в подкаталоге значений. Такие id ресурсов выражаются в файле R.java как R.drawable.*. ХМL-узел для такого файла: /resources/drawable. В Android при помощи специальных ХМL-файлов, расположенных в /res/drawable, также подерживаются скругленные и градиентные прямоугольники. Корневым ХМL-тегом для drawable является <shape>. Идентификаторы таких ресурсов выражаются в файле R.java как R.drawable.*. В таком случае, каждое имя файла преобразуется в уникальный id отрисовываемого объекта.
	__- Анимация - /res/anim/ваш_файл - Android может выполнить простую анимацию на графике или на серии графических изображений. Анимация включает вращения, постепенное изменение, перемещение и протяжение.__
	- Произвольные XML-файлы - /res/xml/*.xml - в Android в качестве ресурсов могут использоваться произвольные XML-файлы. Они компилируются в aapt. Идентификаторы таких ресурсов также выражаются в файле R.java как R.xml.*
	- Произвольные необработанные ресурсы - /res/raw/*.* - любые нескомпилированные двоичные или текстовые файлы, например, видео. Каждый файл получает уникальный id ресурса. Идентификаторы таких ресурсов выражаются в файле R.java как R.raw.*
	- Произвольные необработанные активы - /assets/*.*/*.* - можно использовать произвольные файлы в произвольно названных каталогах, которые находятся в подкаталоге /assets. Это не ресурсы, а просто необработанные файлы. В этом каталоге, в отличие от /res, подкаталоги могут располагаться на любой глубине. Для таких файлов не создаются идентификаторы ресурсов. При работе с ними нужно использовать относительное имя пути, начиная с /assets, но не указываея этого каталгоа в имени пути.

= = = = = = = = = = = = = =

Синтаксис ссылок на ресурсы
Все ресурсы Android идентифицируются по их id, содержащемуся в исходном коде Jаvа. Синтаксис, используемый при связывания id с ресурсом в файле XML, называется синтаксис ссылок на ресурс (resource-reference syntax). Синтаксис атрибута id в предыдущем примере @+id/textl имеет следующую структуру:
 
@[package:]type/name
Параметр tуре соответствует одному из пространств имен:
* R.drawable
* R.id
* R.layout
* R.string
* R.attr
* и др.
Параметр name - это имя ресурса. Оно также представлено в виде константы int в файле R.java.
Если не указывать пакет (package), то разрешение пары type/name будет производиться на основе локальных ресурсов и локального пакета R.java. Если указать android:type/name, то связывание ID ссылки будет производиться с применением пакета Android, в частности с использованием файла android.R.java. Вы можете использовать имя любого java-пакета вместо подстановочного слова package, чтобы использовать файл R.java, подходящий для связывания ссылки.
Рассмотрим несколько примеров
TextView android:id="text" - Ошибка компиляции, так как id не принимает необработанные текстовые строки.
TextView android:id="@text" - Неправильный синтаксис. Не хватает названия типа. Вы получите сообщение об ошибке "No Resource type specified"
TextView android:id="@id/text - Ошибка: не найдено ни одного ресурса, соответствующего id "text". Возможно, вы не задали "text" как один из видов ID
TextView android:id="@android:id/text" - Ошибка: Ресурс не является общедоступным". Означает, что такой id отсутствует в android.R.id. Чтобы такая запись была действительной, необходимо в файле Android.R.java задать id с таким именем
TextView android:id=="@+id/text - Успешно: создает id с названием "text" в файле R.java локального пакета.
Определение собственных идентификационных номеров ресурсов для последующего использования
Общий принцип присвоения id предполагает либо создание нового id для ресурса, либо использование одного из id, созданных в пакете Android. Однако id можно создавать и заранее, а потом использовать их в собственных пакетах.
Строка <TextView android:id="@+id/text"> в предыдущем фрагменте кода указывает, что id с названием text, будет использоваться в том случае, если этот id уже создан. Если id еще не существует, нужно создать новый идентификатор. В связи с этим возникает вопрос: может ли id, например, text уже существовать в файле R.java, чтобы такой идентификатор можно было использовать многократно?
Можно предположить, что такую задачу могла бы выполнять константа, например R.id.text, находящаяся в файле R.java, но R.java не поддается редактированию. Даже, если бы было возможно внести такие изменения, файл приходилось бы заново генерировать после добавления, изменения или удаления любой информации из подкаталога res/*.
Решение проблемы заключается в использовании тега ресурса под названием item для задания id, не связанного ни с каким конкретным ресурсом. Ниже приведен соответствующий пример:

<resources> 
<item  type="id"  name="text "/> 
</ resources> 
Здесь type описывает тип ресурса, в данном случае id. Когда id будет установлен, будет работать и следующее определение View:
 
<TextView  android:id="@id/text"/>

= = = = = = = = = = = = = =

Скомпилированные и нескомпилированные ресурсы Android
Большинство ресурсов компилируются в двоичные файлы, но некоторые используются без дополнительной обработки. В Android поддержка ресурсов осуществляется преимущественно при помощи файлов двух типов - XML и RAW-файлов (к последним относятся изображения, аудио и видео). При работе с ХМL-файлами мы видели, что в большинстве случаев ресурсы определяются как значения внутри файла XML (это касается, например, строк), а иногда весь ХМL-файл является ресурсом (например, файл ресурса разметки).
Файлы, созданные в XML, также подразделяются на два типа: первые компилируются в двоичный формат, а вторые копируются на устройство без изменений. Например, XML-файлы строковых ресурсов и ресурсов разметки компилируются в двоичный формат. Эти ХМL-файлы имеют заданный формат, в котором узлы XML преобразуются в ID.

= = = = = = = = = = = = = =

Использование ресурсов в коде программы
Подведем воедино информацию об использовании ресурсов в коде программы.
Во время компиляции генерируется статический класс R на основе ваших ресурсов и содержит идентификаторы всех ресурсов в программе. Класс R имеет несколько вложенных классов, один для каждого типа ресурса, поддерживаемого системой Android, и для которого в проекте существует файл ресурса. Класс R может содержать следующие вложенные классы:
* R.anim — идентификаторы для файлов из каталога res/anim/ (анимация);
* R.array — идентификаторы для файлов из каталога res/values/ (массивы);
* R.bool — идентификаторы для битовых массивов в файлах arrays.xml из каталога res/values/;
* R.integer — идентификаторы для целочисленных массивов в файлах arrays.xml из каталога res/values/;
* R.color — идентификаторы для файлов colors.xml из каталога res/values/ (цвета);
* R.dimen — идентификаторы для файлов dimens.xml из каталога res/values/ (размеры);
* R.drawable — идентификаторы для файлов из каталога res/drawable/ (изображения);
* R.id — идентификаторы представлений и групп представлений для файлов ХМL-разметки из каталога res/layout/;
* R.layout — идентификаторы для файлов разметки из каталога res/layout/;
* R.raw — идентификаторы для файлов из каталога res/raw/;
* R.string — идентификаторы для файлов strings.xml из каталога res/values/ (строки);
* R.style — идентификаторы для файлов styles.xml из каталога res/values/ (стили);
* R.xml — идентификаторы для файлов из каталога res/xml/.
Синтаксис для обращения к ресурсу:
R.resource_type.resource_name 
При использовании системных ресурсов используется класс android.R.
 
android.R.drawable.sym_def_app_icon; // стандартный значок приложения
android.R.style.Theme_Black;  // загрузить стандартный стиль: 
Если в коде вам понадобится идентификатор ресурса для конструктора или метода, то можете использовать данные свойства:

setContentView(R.layout.activity_main); // загрузка ресурса разметки

// Строковый ресурс используется при выводе Toast-сообщения
Toast.makeText(this, R.string.mytext, Toast.LENGTH_LONG).show();
Если вам нужен не идентификатор, а сам экземпляр ресурса, то используйте метод getResources для доступа к экземпляру класса Resources:

Resources myResources = getResources();
Принцип работы класса Resources заключается в передаче идентификатора ресурса, чей экземпляр вам нужен для работы. Вот несколько примеров получения экземпляров ресурсов:

Resources myResources = getResources();

CharSequence myText = myResources.getText(R.string.hello_app); // получим строку
Drawable myIcon = myResources.getDrawable(R.drawable.app_icon); // получим значок
int myColor = myResources.getColor(R.color.color_blue); // получим значение цвета
float myWidth = myResources.getDimension(R.dimen.width_border); // получим размер

// Получим массив строк
String[] stringArray;
stringArray = myResources.getStringArray(R.array.string_array);

// Ресурс, содержащий пошаговую анимацию, возвращается в виде объекта AnimationResources
// Также можно вернуть значение с помощью метода getDrawable и привести к нужному типу
AnimationDrawable cat;
cat = (AnimationDrawable)myResources.getDrawable(R.drawable.frame_cat);
Итак, к графическим ресурсам можно обратиться через R.drawable.cat (файл cat.png), а к музыкальным трекам через R.raw.meow (файл meow.mp3) и по аналогии с другими типами ресурсов.
Иногда требуется большей гибкости при использовании файлов из ресурсов. Например, в приложении нужно использовать имена ресурсов. В этом случае есть два подхода для получения информации о ресурсе.
Первый способ:

android.resource://[package]/[res type]/[res name]

Uri.parse("android.resource://ru.alexanderklimov.test/raw/filename");
Второй способ с использованием идентификатора (не особо нужен):

android.resource://[package]/[resource_id]

Uri.parse("android.resource://ru.alexanderklimov.test/" + R.raw.filename);
Допустим, у вас файлы имеют схожие имена meow1.mp3, meow2.mp3, meow3.mp3. По приведённой выше схеме не составит труда создать переменную типа String fileName = "meow" + n. Такой подход может пригодиться в циклах, когда счётчик можно сопоставить с именем файла.
Можете заменить имя пакета на программное извлечение с помощью метода Context.getPackageName().
Ещё один полезный способ, который может пригодиться. Получить идентификатор по имени файла (без расширения) при помощи метода getIdentifier():

int resourceID = this.getResources().getIdentifier("filename",
		"raw", this.getPackageName());
mediaPlayer = MediaPlayer.create(getApplicationContext(),
		resourceID);
Пример для графического ресурса.

String mDrawableName = "cat1"; // файл cat1.jpg в папке drawable
int resID = getResources().getIdentifier(mDrawableName, "drawable", getPackageName());
Иногда нужно получить не сам идентификатор, а его имя, чтобы сохранить его, скажем, в базе данных. Воспользуйтесь следующим приёмом, используя методgetResourceEntryName():

// вернёт cat1
Log.i("id", this.getResources().getResourceEntryName(R.drawable.cat1));
Или так

// вернет ru.alexanderklimov.test:drawable/cat1
Log.i("id", getResources().getResourceName(R.drawable.cat1));

// вернёт res/drawable/cat1.jpg
Log.i("id", getResources().getString(R.drawable.cat1));
// вернёт тот же результат
Log.i("getText()", this.getResources().getText(R.drawable.cat1).toString());

= = = = = = = = = = = = = =

Вложенные ресурсы
Можно использовать ссылки на ресурсы в качестве значений для атрибутов внутри других ресурсов (разметка, стили), что позволяет создавать специальные варианты визуальных тем, локализованных строк и графических объектов. Чтобы сослаться на один ресурс внутри другого, используйте символ @ в следующем виде:

attribute = "@[packagename:]resourcetype/resourceID"
Полное имя packagename нужно указывать только при использовании сторонних пакетов, при использовании собственных ресурсов данный параметр можно опустить, так как Android предполагает, что вы используете ресурсы пакета со своим приложением.

...
android:text="@string/hello_app"
android:textColor="@color/color_blue"
...

= = = = = = = = = = = = = =

Использование системных ресурсов
Сама система имеет собственные ресурсы (строки, изображения, анимация, разметки, стили), которые используются стандартными приложениями, входящими в состав Android. Вы также можете использовать данные системные ресурсы в своих приложениях, добиваясь единообразного стиля и дизайна.
Получение доступа к системным ресурсам внутри кода программы ничем не отличается от приведенных выше примеров. Единственно, в чем состоит отличие, это использование не вашего класса R, а системного класса android.R. Например, для получения строки, которая хранит сообщение об ошибке, используется следующий код:

CharSequence errorMessage = getString(android.R.string.httpErrorBadUrl);
Чтобы получить доступ к системным ресурсам внутри XML-файла, используйте значение android следующим образом:

...
android:text="@android:string/httpErrorBadUrl"
android:textColor="@android:color/darker_gray"
...

= = = = = = = = = = = = = =

Использование ссылок на визуальные стили в текущей теме
Использование визуальных тем позволяет обеспечить целостность пользовательского интерфейса приложения. Вместо описания каждого стиля, вы можете использовать ссылки, предоставляемые Android, с помощью которых вы можете использовать стили из текущей темы.
Чтобы задать ссылку на ресурс, который нужно применить, вместо символа @ укажите префикс ?. Например, предыдущий пример можно переделать следующим образом:

android:textColor="?android:textColor"
android:background="?colorPrimary"
Такой подход позволяет создавать визуальные стили, которые смогут меняться по мере преобразований в текущей теме, и избавляет от необходимости редактировать каждый отдельный ресурс.

= = = = = = = = = = = = = =

Создание ресурсов для локализации и аппаратных конфигураций
Применение ресурсов позволяет использовать механизм динамического выбора нужного ресурса в программе. Можно задать определенную структуру каталогов в проекте, чтобы создавать ресурсы для конкретных языков, регионов и аппаратных конфигураций. Во время выполнения программы Android выберет нужные значения для конкретного телефона пользователя.
Вы можете указывать альтернативные значения, создавая собственные структуры каталогов внутри каталога res при помощи дефиса (-). Например, мы хотим создать дополнительные строковые ресурсы для французского языка, франкоканадского региона и для русского языка. Тогда структура каталогов в проекте будет выглядять следующим образом:
Project/
	res/
		values/
			strings.xml
		values-fr/
			strings.xml
		values-fr-rCA
			strings.xml
		values-ru/
			strings.xml
Как видите, мы создали несколько файлов strings.xml, которые содержат текст на французском и русском языках и раскидали их по нужным каталогам. Далее приводится список возможных идентификаторов, которые можно использовать для создания альтернативных значений в ресурсах.
Регионы и язык можно указывать без всякой связи друг с другом. Так в папке values-ru-rJP будут храниться русские тексты для жителей Японии.
* Мобильный код страны и код мобильного оператора (MCC/MNC) - содержит информацию о стране и опционально о мобильной сети, которая привязана к SIM-карте. MCC (Mobile Country Code) состоит из символов mcc, за которыми следует трехзначный код страны. Также можно добавить MNC (Mobile Network Code), используя символы mnc и двухзначный код мобильной сети, например, mcc250-mnc99 (Россия-Билайн). Список кодов MCC/MNC можно посмотреть в Википедии.
* Язык и регион - указывает на язык при помощи языкового кода в формате ISO 639-1. Состоит из двух символов в нижнем регистре. В случае необходимости можно добавить обозначение региона в виде символа r и двухсимвольного кода в формате ISO 3166-1-alpha-2, записанного в верхнем регистре, например, en-rUS, en-rGB, fr-rCA.
* Размер экрана - может иметь одно из следующих значений:
o	small - меньше, чем HVGA, 3.2 дюйма
o	medium - HVGA или меньше, чем HVGA, типичный размер
o	large - VGA или больше, планшет или нетбук
* Высота и ширина экрана - можно использовать значения
o	long — для экранов, которые в альбомном режиме значительно шире, чем на стандартных смартфонах (таких как G1);
o	notlong — для экранов с обычным соотношением сторон
* Ориентация экрана - возможны значения port (Портретный), land (Альбомный), square (Квадратные экраны).
* Плотность пикселов на экране - возможны значения:
o	ldpi — предназначен для хранения ресурсов, рассчитанных на экраны с низкой плотностью пикселей (100–140 dpi);
o	mdpi — для экранов со средней плотностью пикселей (140–180 dpi);
o	hdpi — для экранов с высокой плотностью пикселей (190–250 dpi);
o	xdpi - новый тип для очень высокой плотности для планшетов
o	nodpi - Вы можете использовать значение nodpi для растровых ресурсов, которые не должны масштабироваться. В этом случае система не требует точного совпадения.
Подбирая подходящий каталог, Android выберет тот спецификатор, который наиболее точно описывает плотность пикселей экрана устройства и откорректирует масштаб объекта Drawable. По умолчанию, в новом проекте создаются папки drawable-ldpi, drawable-mdpi, drawable-hdpi, drawable-xhdpi, в которых содержатся значки для приложения.
* Тип сенсорного экрана - возможны варианты: notouch, stylus, finger.
* Наличие клавиатуры - возможны варианты: keysexposed, keyshidden, keysoft.
* Тип ввода - возможны варианты: nokeys, qwerty, 12key.
* Способ навигации - возможны варианты: nonav, dpad, trackball, wheel.
Вы можете комбинировать указанные спецификаторы, разделяя их дефисами. Поддерживаются любые сочетания, однако они должны идти в том порядке, как указано в списке, т.е. язык всегда указывается раньше ориентации экрана и т.п. В одном спецификаторе может применяться не более одного значения.
Корректные варианты
drawable-en-rUS
drawable-en-keyshidden
drawable-long-land-notouch-nokeys
Некорректные варианты
drawable-rUS-en (нарушен порядок)
drawable-nonav-dpad (несколько значениф для одного спецификатора)
Если на устройстве не будет обнаружено соответствующих ресурсов, при попытке получения доступа к ним ваша программа сгенерирует исключение. Чтобы избежать подобной ситуации, необходимо всегда добавлять значения по умолчанию для всех типов ресурсов в каталог без спецификаторов.
Пример с локализацией программы можно посмотреть в статье Локализация приложений (http://developer.alexanderklimov.ru/android/locale.php).

= = = = = = = = = = = = = =

Псевдонимы (alias)
Чтобы избежать дублирования ресурсов, можно использовать псевдонимы, которые будут ссылаться на один и тот же ресурс. Предположим вы создали два файла res/layout-land/activity_main.xml и res/layout-large/activity_main.xml с одинаковым содержанием для разметки с альбомной ориентацией для смартфонов и планшетов. Создайте теперь ещё один файл с таким же содержанием, например под именем res/layout/activity_main_horizontal.xml. Теперь два одинаковых файла можете удалить. Вместо них создайте два файла res/values-land/refs.xml и res/values-large/refs.xml.

<resources>
	<item type="layout" name="activity_main">@layout/activity_main_horizontal</item>
</resources>
Такой приём часто применяется при использовании фрагментов.

= = = = = = = = = = = = = =

Получение идентификаторов ресурсов приложения
Врядли вам пригодится этот код в жизни. Для общего развития.

public void getAllResourceId() {
	final R.id idResources = new R.id();
	final Class<R.id> c = R.id.class;
	final java.lang.reflect.Field[] fields = c.getDeclaredFields();

	for (Field field : fields) {
		final int resourceId;
		try {
			resourceId = field.getInt(idResources);
			Log.i("ID", "resourceId: " + resourceId + " Name:" + field.getName());

		} catch (Exception e) {
			Log.e("Exception", e.getLocalizedMessage());
		}
	}
}


= = = = = = = = = = = = = =

= = = = = = = = = = = = = =

= = = = = = = = = = = = = =




















