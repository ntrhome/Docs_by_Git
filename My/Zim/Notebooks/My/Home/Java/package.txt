Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-07-17T02:12:09+03:00

====== package ======
Created Wednesday 17 July 2019

Пакеты являются контейнерами классов, служащими одновременно:
	- механизмом разделения пространств имен классов (т.о. одноименные классы могут мирно сосуществовать в разных пакетах), и
	- механизмом управления доступом к классам (в плане доступа пакет живет тремя жизнями: 
			- - это доступ внутри иерархии пакета, 
			- - запуск классов (не обязательно паблик, но содержащих main) через команду джаве, вида java my.package.MyPublicClass;
- - доступ только к паблик-классам, импортированным в пользовательский код.

- - - - - - - - - - - - 

**Определение (создание) пакета:**

Если оператор package отсутствует, то имена классов размещаются в пакете, используемом по умолча­нию(т.е. в текущем каталоге?) и не имеющем имени. Но такой подход не годится для реальных приложений со значительным числом классов.

Пакеты (байт-код файлы - .class) хранятся в ветви каталогов файловой системы (которая может быть запакована в .jar) - назовем ее "пакетной ветвью". Места расположения таких ветвей (их корневого каталога, или .jar-файла) задаются джавке одним из 4-х способов:
	1) это или текущий рабочий каталог (Му - там где лежит компилируемый .java или запускаемый .class (.jar) файл?);
	2) или пути, указанные в переменной окружения CLASSPATH (export CLASSPATH=/home/my/prj/lib/CoolFramework.jar:/home/my/prj/);
	3) или пути, указанные командам java и javac через параметр -classpath (аналогично содержимому CLASSPATH) или через системную опцию java.class.path __(?)__.
	4) __также с JDK 9 - пакет может быть составной частью модуля, и быть найден по пути к модулю (глава 16).__

Исходный код пакета должен содержать в 1-й строке инструкцию вида:
		package my.package; //после нее могут идти import, а потом уже код.
где "my.package" - имя пакета и одновременно это путь пакета внутри пакетной ветви, написанный через точку (регистр имеет значение, принято маленькими). 
__Единственный в этом файле public-класс (нельзя больше 1-го public-класса в файле) станет импортируемым пакетным классом. Остальные классы (без паблик) компилятор также выделит из исходника и положит в отдельные .class-файлы байткода, имогут быть пользованы внутри пакетно или командой джавки вида ____my.package.MyPublicClass.__

Вызывать пакетные классы можно командой вида 
		java my.package.MyPublicClass
находясь при этом в рабочем каталоге, содержащем каталог my, либо джавка другим способом (выше) извещен о местонахождении в файловой системе отправной точки-каталога, в котором содержится my (но это не будет работать, если в MyPublicClass.java не был задан пакет - package my.package;).

Имена пакетов (каталогов) следует выбирать тщательно - любое изменение чревато отслеживанием соответствия всех элементов.

Каждый пакет (каталог в пакетной ветви) содержит любое число разноименных классов.



	


















