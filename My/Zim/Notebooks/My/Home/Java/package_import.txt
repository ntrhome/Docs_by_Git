Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-07-17T02:12:09+03:00

====== package import ======
Created Wednesday 17 July 2019

Пакеты являются контейнерами классов (и других подчиненных пакетов), служащими одновременно (2):
	- механизмом разделения пространств имен классов (т.о. одноименные классы могут мирно сосуществовать в разных пакетах), и
	- механизмом управления доступом к классам (в плане доступа пакет живет тремя жизнями: 
			- - это доступ внутри иерархии пакета, 
			- - запуск классов (не обязательно паблик, но содержащих main) через команду джаве, вида java my.package.MyPublicClass;
			- - доступ только к паблик-классам, импортированным в пользовательский код.
	- инкапсуляции.

Пакеты - что-то вроде ветвей иерархии вложенных спейсов, но ветвь синхронна с расположением фалов .class в файловой системе (или в структуре архива .jar).

- - - - - - - - - - - - 

**Определение (создание) пакета:**

Если оператор package отсутствует, то имена классов размещаются в пакете, используемом по умолча­нию(т.е. в текущем каталоге?) и не имеющем имени. Но такой подход не годится для реальных приложений со значительным числом классов.

Пакеты (байт-код файлы - .class) хранятся в ветви каталогов файловой системы (которая может быть запакована в .jar) - назовем ее "пакетной ветвью". Места расположения таких ветвей (их корневого каталога, или .jar-файла) задаются джавке одним из 4-х способов:
	1) это или текущий рабочий каталог (Му - там где лежит компилируемый .java или запускаемый .class (.jar) файл?);
	2) или пути, указанные в переменной окружения CLASSPATH (export CLASSPATH=/home/my/prj/lib/CoolFramework.jar:/home/my/prj/);
	3) или пути, указанные командам java и javac через параметр -classpath (аналогично содержимому CLASSPATH) или через системную опцию java.class.path __(?)__.
	4) __также с JDK 9 - пакет может быть составной частью модуля, и быть найден по пути к модулю (глава 16).__

Исходный код пакета должен содержать в 1-й строке инструкцию вида:
		package my.package; //после нее могут идти import, а потом уже код.
где "my.package" - имя пакета и одновременно это путь пакета внутри пакетной ветви, написанный через точку (регистр имеет значение, принято маленькими). 
__Единственный в этом файле public-класс (нельзя больше 1-го public-класса в файле) станет импортируемым пакетным классом. Остальные классы (без паблик) компилятор также выделит из исходника и положит в отдельные .class-файлы байткода, имогут быть пользованы внутри пакетно или командой джавки вида my.package.MyPublicClass.__

Вызывать пакетные классы можно командой вида 
		java my.package.MyPublicClass
находясь при этом в рабочем каталоге, содержащем каталог my, либо джавка другим способом (выше) извещен о местонахождении в файловой системе отправной точки-каталога, в котором содержится my (но это не будет работать, если в MyPublicClass.java не был задан пакет - package my.package;).

Имена пакетов (каталогов) следует выбирать тщательно - любое изменение чревато отслеживанием соответствия всех элементов.

Каждый пакет (каталог в пакетной ветви) содержит любое число разноименных классов.


= = = = = = = = = = = = = = = **import**

Оператор import имеет следующую общую форму:

		**import пакет1[.пакет2].(имя_класса | *); **//конкретный класс либо весь пакет

В исходном коде операторы import должны следовать сразу после оператора package (если таковой имеется) и перед любыми опреде­ лениями классов.

import - это оператор-удобство а не необходимость. В принципе, если пакет доступен (т.е. джавка знает где его искать - см. выше), то  везде, где допускается имя класса, можно указать цепочку иерархии пакета и имя этого класса, т.е. вместо:
		**import java.util.*;**
		**import java.io.IOException;**
можно калякнуть:
		class MyDate extends **java.util.Date** { ... catch (**java.io.IOException** e) ... }
		catch (**java.io.IOException** e){.

Т.о. после того как класс импортирован, на него можно ссылаться непосредственно, используя только его имя (а не весь путь).

Компилятор никак не отреагирует на наличие **классов с одинаковыми имена­ми в двух разных пакетах**, импортируемых в форме со звездочкой, если только не будет предпринята попытка воспользоваться одним из этих классов. В таком слу­чае возникнет ошибка во время компиляции, и тогда имя класса придется указать явно вместе с его пакетом.

Все классы из стандартной библиотеки Java хранятся в пакете java.
Основные языковые средства хранятся в пакете java.lang, входящем в пакет java.
Обычно каждый пакет или класс, который требуется использовать, приходится импортировать. Но, поскольку программировать на Java бесполезно без многих средств, определенных в пакете java.lang, компилятор неявно импортирует его для всех программ. Это равнозначно наличию следующей строки кода в каждой из программ на Java:
		import java.lang.*;



















