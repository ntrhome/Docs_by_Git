Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-06-16T19:34:49+03:00

====== Classes ======
Created Воскресенье 16 июня 2019

**Класс - это сложный тип, содержащий члены - свойства и методы **(в джавке называемый еще шаблоном объекта).

Класс - наименьшая единица абстракции в джавке.

Если класс публичный, то его **исходный код** должен размещаться в отдельном одноименном файле.

**Объект - реализованный в памяти экземпляр класса.**
Класс это логический каркас, определяющий взаимосвязь между его членами, а объект - это его физическая сущность, занимающая конкретный кусок памяти.

**Создание объекта** - двуэтапно: 
- декларация имени (ссылка на объект, начальное значение для типа =null),
- дефинация объекта (динамическая, через new - резервирует память, возвращает ссылку - дескриптор объекта в памяти):
		Box x /*=null*/; x = new Box();	
		Box x = new Box(); //можно объеденить
Если new неудачно, то исключение времени выполнения.
Имя класса со скобками в "new Box()" означает команду вызова **конструктора **класса, в скобках могут быть аргументы для конструктора.

**Конструктор объекта вызывается в обязательном порядке при его создании (new).**

**Присваивание ссылок - создание копии ссылки (не объекта):** 
когда мы присваиваем ссылке на объект ссылку на объект, то мы оперируем сугубо ссылками, без копирования объекта:
		Box x = new Box();
		Box y = x; //"y" и "x" ссылаются на один и тот же объект.
		Box x = null; //разрывает связь ссылки с объектом (теперь доступ к объекту сохранился только у "y"), но объект существует пока на него есть хоть одна действующая ссылка.

**getClass().getName()** - иногда в коде нужно получить имя текущего класса. Для этого есть специальные методы getClass().getName() и другие родственные методы.

__= = = = = = = = = = = = = = = доработать:__



**Порядок инициализации объекта - класс без наследования:**
		
		1. создаются, становятся доступны члены:
				- поля (пока без инициализации - содержат начальные значения для типа),
				- методы;
						//class A{ int i,j,k; int initJ(); A(); }//

		2. последовательная инициализация полей (слева направо, сверху вниз), 
				причем если при инициализации текущего поля обратиться (в методе) к следующему по порядку полю, то следующее опять же еще неинициализировано и содержит начальное для типа значение;
						//class A{ int i=5,j=initJ(),k=10; int initJ(){return k+5;} A(); }//
		
		3. работает конструктор.
						//class A{ int i=5,j=initJ(),k=10; int initJ(){return k+5;} A(){...}; }//

(Порядок инициализации объекта при наследовании классов, см. в [[Types:Classes:extends]]).

**Порядок инициализации объекта - класс с наследованием: K∈[1..N]**
Для иерархии [1..N], создаваемого объекта K∈[1..N] инициализация идет сначала циклом от K до 1:
		1) создаются, становятся доступны члены [K..1]:
				- поля (пока без инициализации - содержат начальные значения для типа),
				- методы;
						//class   K{ int i,j,k; int initJ();   K(); } //конструктор будет пользовать переопределяемый initJ()//
						//class K-1{ int i,j,k; int initJ(); K-1(); }//
						...
						//class   1{ int i,j,k; int initJ();   1(); }//
				__Именно так, потому что дойдя до итерации 1 будет выполняться конструктор 1, и он уже будет знать о переопределении (перекрытии) методов (здесь initJ()) вплоть до K. При этом каждый метод (включая конструктор) обращаясь к полям, будет обращаться к тому экземпляру полей, который актуален для его класса (проверял адресом ссылки-объектика).__

Теперь итерация пойдет обратно от 1 до K, назовем текущию итерацию P и сейчас P=1.
		
		2) выполняется инициализация объекта P:
			2.0) версии методов уже актуальны - с учетом переопределения до уровня K;
			2.1) выполняется последовательная инициализация полей (слева направо, сверху вниз), 
					причем если при инициализации текущего поля задействован метод, который использует следующее по порядку поле (или, если этот метод переопределен, то актуальную для его класса версию поля), то оно опять же еще не инициализировано и содержит начальное для типа значение;
			2.2) работает конструктор P.

