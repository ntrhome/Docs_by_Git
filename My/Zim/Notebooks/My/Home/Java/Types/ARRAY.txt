Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-06-16T19:37:19+03:00

====== ARRAY ======
Created Воскресенье 16 июня 2019

=================**Java - массив:**
**Массив - встроенный в Java класс (работает как Object).**

Декларация (память не выделена):
		int a[];	//a ==> null
		int[] a, b;	//можно (и a и b - массивы, в отличии от С)
Память под массивы выделяется динамически (по мере дефинации - см. многомерные).
Декларация вместе с дефинацией (выделение памяти):
		int c[] = new int[5];	//c ==> int[5] { 0, 0, 0, 0, 0 }
		int d[] = {1,2};	//d ==> int[2] { 1, 2 }
Но хотя память и выделяется динамически, созданный массив является статическим (не может изменить размер, но может быть заменен - редефинирован по тому же имени).
Дефинация и редифинация:
		a = new int[6]; 	//a ==> int[6] { 0, 0, 0, 0, 0, 0 }
		a = new int[]{1,2,3};	//a ==> int[3] { 1, 2, 3 }

Методы могут возвращать массивы в качестве результата.

В случае, когда тип массива - объекты, то добавляется дефинация элемента:
- декларация такая же: Object obj[];
- дефинация массива: obj = new Object[5];
- дефинация элемента: obj[0] = new Object("Vasia", 5); //и это здорово - применяем конструкторы.


**Ситуацию unbound джавка отслеживает.**

**Поле .length содержит количество элементов, под которое зарезервирован массив (не важно сколько из них инициализировано):**
		month_days.length

Механизмы от Object, на подобие:
		int[] i = {1,6,4,2}, j;
		j = i.clone();
		System.out.println(i.getClass().getName());
- работают.


- - - - - - - - - - - - - - - - - **к пониманию - массив объектов:**
public class Array 
{   
	public static void main(String[] args) 
	{
		System.out.println("Инициализируем в цикле:");
		Element pp[] = new Element[3]; //создает указатель на, и саму последовательность указателей (каждый =null)
		for (int i=0; i<pp.length; ++i)	{pp[i] = new Element();}//создает объект и устанавливает на него указатель
		for(var e:pp) e.print();
		
		System.out.println("Инициализируем вручную:");
		Element oo[] = {new Element(), new Element(100), new Element()};
		for(var e:oo) e.print();
		
		System.out.println("Иначе создается массив примитивных:");
		int arr[] = new int[3]; //создает указатель на, и саму последовательность примитивных (каждый =0)
		for(var e:arr) System.out.println(e);
	}
}

class Element
{
	static int n=0;
	public int index;
	Element()
	{
		index = ++n;
	}
	Element(int i)
	{
		++n;
		index = i;
	}
	void print()
	{
					System.out.println("Element # " + index + " of " + n + " (this=" + this + ")");
	}
}
- - - - - - - - - - - - - - - - -
**Многомерный массив** - это массив массивов массивов массивов массивов...

При любой его N-мерности сводится к 2-м конструкциям:
	1) N-1 раз : указатель на расположенные в памяти указатели, адресуемые как (указатель + размер_указателя * индекс_указателя),
	2) 1 конечный раз: указатель на последовательно расположенные в памяти элементы, адресуемые как (указатель + размер_элемента * индекс_элемента).

	int two[][] = new int[2][3];
	//two ==> int[2][] {
											int[3] { 0, 0, 0 }, 
											int[3] { 0, 0, 0 } 	
										}

	int three[][][] = new int[2][3][2];
	//three ==> int[2][][] { 
													int[3][] { 
																		int[2] { 0, 0 }, 
																		int[2] { 0, 0 }
																	 } 
												}

При резервировании памяти для многомерного массива достаточно сначала указать размер только для первого (левого) индекса, остальную размерность можно задавать поуровнево - от левого индекса к правому. 
int a[][][][] = new int [3][][][]; //пример too long
Причем __!!!__ эта размерность может быть различной для каждого уровня (на примере с инициализацией):
	int[][][] a = {	
									{ {1,2}, {3,4,5}, {6,7} },
									{ {1,2}                 },
									{ {1,2}, {3,4,5,6}      } 
							  };
	//a ==> int[3][][] { 
							int[3][] { 
										int[2] { 1, 2 }, 
										int[3] { 3, 4, 5 }, 
										int[2] { 6, 7 }
										}, 
							int[1][] { 
										int[2] { 1, 2 } 
										}, 
							int[2][] { 
										int[2] { 1, 2 }, 
										int[4] { 3, 4, 5, 6 }
										} 
							}
- - - - - - - - - - - - - - - - -
**Итерация в многомерных массивах:**

Но не следует забывать, что в Java многомерные массивы представляют собой массивы массивов.

Данное обстоятельство важно иметь в виду при переборе многомерного массива, поскольку результатом каждой итерации оказывается сле­дующий массив, а не отдельный элемент.

Более того, тип итерационной перемен­ной цикла for должен быть совместим с типом получаемого массива. Например, в двухмерном массиве итерационная переменная должна быть ссылкой на од­номерный массив.

В общем случае при использовании цикла в стиле for each для перебора массива размерностью N получаемые в итоге объекты будут массивами размерностью N-1.

Пример:
int nums[] [] = new int[З] [5];
//заполняем массив ...
for(int х[] : nums)	//ссыл­ка на вложенный одномерный массив
	for(int у : х) 
		System.out.println("Знaчeниe равно: " + у);

- - - - - - - - - - - - - - - - - **Для примитивного массива можно пользовать средства класса Arrays:**
__СТАТИЧЕСКИЙ МЕТОД???__

System.out.println(Arrays.toString(myarray));
> [0,1,2,3]
- - - - - - - - - - - - - - - - -

	
	











