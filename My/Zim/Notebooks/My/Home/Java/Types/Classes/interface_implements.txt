Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-07-17T02:26:11+03:00

====== interface implements ======
Created Wednesday 17 July 2019

**Объявление интерфейса:**

Интерфейс, это аналог полностью абстрактного класса.

Имплементированный интерфейс гарантирует наличие у класса методов с прописанной в нем сигнатурой (неважно как класс будет обеспечивать эти методы: реализует сам, получит по наследству или будет применяться реализация по умолчанию из интерфейса).

Как и абстрактный класс, интерфейс может:
	- иметь модификатор **public** - тогда он доступен везде (в этом случае интерфейс должен быть единствен­ным открытым интерфейсом, объявленным в файле, а имя этого файла должносовпадать с именем интерфейса.), или
	- не иметь модификатора **(no_modifier - доступ по умолчанию)** тогда он доступен только в своем пакете.

Сам интерфейс может содержать:
	- статические финальные переменные (причем final и static присутствуют неявно), которые должны быть инициализированы;
	- и абстрактные методы (причем abstract присутствет неявно), однако с  JDK 8 в интерфейсе можно определять реализацию метода по умолчанию.

Все методы и переменные неявно объявляются в интер­фейсе как **рublic**.

Класс может имплементировать больше одного интерфейса (через запятую):
		public interface Foo{
				int INTEGER = 5;
				void info(){ System.out.println("It's metod from interface."); }
		}
		interface Boo{
				int data(int x);
		}
причем объявленные в них методы могут дублироваться в нескольких интерфейсах.

- - - - - - - - - - - - 

**Имплементирование интерфейса:**

		[доступ] class имя_класса [extends суперкласс]
		[implements интерфейс [, интерфейс ... ]] {
				//тело класса
		}

Методы, реализующие элементы интерфейса, должны быть объявлены как **public**.
	class Loo implements Foo, Boo {
				int data(int x) {
						return x*x;
				}
		}

- - - - - - - - - - - - 

Интерфейс является **типом**, переменная его типа может служить ссылкой на класс (как восходящие ссылки у обычных классов)(версию переопределенного члена определяет уровень объекта). Соответственно, переменная типа ин­терфейс располагает только сведениями о методах, объявленных в том интерфей­се, на который она ссылается (перечень доступных методов определяет тип ссытки).

Поиск исполняемого метода осуществляется динамически во время выполнения, что позволяет создавать клас­сы позднее, чем код, из которого вызываются методы этих классов. Вызывающий код может выполнять диспетчеризацию методов с помощью интерфейса, даже не имея никаких сведений о вызываемом коде. Работают правила восходящей ссылки.







