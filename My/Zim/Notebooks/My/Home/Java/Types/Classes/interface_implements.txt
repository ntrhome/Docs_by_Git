Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-07-17T02:26:11+03:00

====== interface implements ======
Created Wednesday 17 July 2019

**Объявление интерфейса:**

Интерфейс, это аналог полностью абстрактного класса. 

Главная суть интерфейса - интерфейс контрактует методы, а имплементирующий класс их обязан реализовать (как гнёзда для подключения других устройств). Остальное - сахар.

Главное отличие интерфейса от класса - неспособность сохранять данные состояния.

Имплементированный интерфейс гарантирует наличие у класса методов с прописанной в нем сигнатурой (неважно как класс будет обеспечивать эти методы: реализует сам, получит по наследству или будет применяться реализация по умолчанию из интерфейса) - принцип "контракта" - "делай все как считаешь нужным, но воплоти именно такой интерфейс".

Как и абстрактный класс, интерфейс может:
	- иметь модификатор **public** - тогда он доступен везде (в этом случае интерфейс должен быть единствен­ным открытым интерфейсом, объявленным в файле, а имя этого файла должносовпадать с именем интерфейса.), или
	- не иметь модификатора **(no_modifier - доступ по умолчанию)** тогда он доступен только в своем пакете.

Сам интерфейс может содержать:
	- статические финальные переменные (причем final и static присутствуют неявно), которые должны быть инициализированы;
	- и абстрактные методы (причем abstract присутствет неявно), 
	- с JDK 8 в интерфейсе можно определять метод с реализацией по умолчанию, маркируемый атрибутом **default**,
	- с JDK 8 в интерфейсе можно определять статические методы, маркируемый атрибутом **static**,
	- с JDK 9 в интерфейсе можно определять закрытый метод, маркируемый атрибутом **private**.

Все методы и переменные неявно объявляются в интер­фейсе как **рublic**.

Класс может имплементировать больше одного интерфейса (через запятую):
		public interface Foo{
				int INTEGER = 5;
				void info(){ System.out.println("It's metod from interface."); }
				default int Goo(String s){ return s.length(); }
		}
		interface Boo{
				int data(int x);
		}
причем объявленные в них методы могут дублироваться в нескольких интерфейсах.

Об **default**-методах (лирика):
	Главной побудительной причиной для внедрения в JDK 8 методов с реализацией по умолчанию было стремление предоставить средства, позволявшие расширять интерфейсы, не нарушая уже существующий код. Напомним, что добавление нового метода в широко применяемый интерфейс нарушит уже существующий код из-за того, что не удастся обнаружить реализацию нового метода. Данное затруднение можно устранить посредством применения метода с реализацией по умолчанию, поскольку он предоставляет реализацию, которая будет использоваться в том случае, если не будет явно предоставленой другой реализации.
	Еще однодной побудительной причиной для внедрения метода по умолчанию было стремление указывать в интерфейсе, по существу, необязательные методы (короче, не ООП-вэй).

О **static**-методах:
	Объявление:
			public interface MyIF {
				...
				static int getDefaultNumber() { return О; }
			}

	вызов не требует имплементации интерфейса, такой метод доступен всегда (аналогично стат-методу класса) через:
			имя_интерфейса.имя_статического_метода
			int defNum = MyIF.getDefaultNumber();
	__Но! Последнее замечание: статические методы из интерфейсов не наследуются ни наследующими интерфейсами, ни имплементирующими их классами (?). [1:278-1]__

Об **private**-методе:
	Поскольку это закрытый метод интерфейса, то им нельзя воспользоваться в коде за пределами того интерфейса, где он определен. Следовательно такой метод можно вызвать только из метода, реализуемого по умолчанию или другого закрытого метода в том же самом интерфейсе.

**Вложенные интерфейсы:**
	Интерфейс может быть членом класса или другого интерфейса.
	Вложенный интерфейс может быть объявлен как puЬlic, private или protected (в отличие от самостоятельного, который может быть или public или no_modofier). Когда вложенный интерфейс используется за пределами объемлющей его области действия, его имя должно быть предварено именем класса или интерфейса, членом которого он является.
	class A{
		public interface NestedInterface{
			boolean isRun();
		}
	}
	class B implements A.NestedInterface { //применить интерфейс, вложенный в другой класс
		public boolean isRun() { return true; }
	}
	class NestedInterfaceDemo {
		public static void main(String args[]} {
			A.NestedInterface nif = new В{};
			if(nif.isRun()) System.out.println("Бежим");
		}
	}
	
**Переменные final в интерфейсах:**
	Применяется для доступа классов, имплементирующих интерфейс, к совместно используемым константам (инициализированных нужным значением), объявленным в этом интерфейсе (могут задавать, например, исходные значения для контрактных методов). Интерфейс может предоставлять имплементирующему классу только константы (без методов).
	int NO=1, YES=2; //в интерфейсе автоматически становятся static и final

	На заметку! Упомянутая методика применения интерфейса для определения общих констант весьма противоречива и представлена ради полноты изложения материала.

- - - - - - - - - 

**Расширение интерфейсов**
	**extends** позволяет одному интерфейсу наследовать другой (аналогично классам) (именно наследовать, поскольку implements - реализовывать).
	
		interface Zoo extends Foo{
				int data(int x);
		}
	Теперь класс, имплементирующий Zoo, должен реализовать методы, законтрактованные и в Foo и в Zoo.


= = = = = = = = = = = = = = = = = = = = 


**Имплементирование интерфейса:**

		[abstract][доступ] class имя_класса [extends суперкласс]
		[implements интерфейс [, интерфейс ... ]] {
				//тело класса
				//[abstract void info();]
		}

Методы, реализующие элементы интерфейса, должны быть объявлены как **public**.
	class Loo implements Foo, Boo {
				int data(int x) {
						return x*x;
				}
		}

Если класс включает в себя интерфейс, но не реализует некоторый определенный в нем метод, то такой метод должен быть объявлен как **abstract** (следовательно абстрактным объявляем и весь такой класс).

**Default** - методы в классе можно не реализовывать (и не упоминать) вовсе (но они будут).

Интерфейс является **типом**, переменная его типа может служить ссылкой на класс (как восходящие ссылки у обычных классов)(версию переопределенного члена определяет уровень объекта). Соответственно, переменная типа ин­терфейс располагает только сведениями о методах, объявленных в том интерфей­се, на который она ссылается (перечень доступных методов определяет тип ссытки).

Поиск исполняемого метода осуществляется динамически во время выполнения, что позволяет создавать клас­сы позднее, чем код, из которого вызываются методы этих классов. Вызывающий код может выполнять диспетчеризацию методов с помощью интерфейса, даже не имея никаких сведений о вызываемом коде. Работают правила восходящей ссылки.

- - - - - - - - - - - - 
= = = = = = = = = = = = = = = = = = = = 
**Разрешение конфликта имен методов с реализацией по умолчанию при наследовании нескольких интерфейсов:**
Несмотря на все сказанное выше, методы с реализацией по умолчанию предоставляют
отчасти возможности, которые обычно связываются с понятием множественного
наследования. Например, в одном классе можно реализовать два интерфейса. Если
в каждом из этих интерфейсов предоставляются методы с реализацией по умолчанию,
то некоторое поведение наследуется от обоих интерфейсов. Поэтому в какой-то, хотя
и ограниченной, степени эти методы все же померживают множественное наследование.
Нетрудно догадаться, что в подобных случаях может возникнуть конфликт имен.

Допустим, два интерфейса, Alpha и Beta, реализуются в классе MyClass.
Что если в обоих этих интерфейсах предоставляется метод reset (), объявляемый
с реализацией по умолчанию? Какой из вариантов этого метода будет выбран
в классе MyClass: из интерфейса Alpha или Beta? С другой стороны, рассмотрим
ситуацию, когда интерфейс Beta расширяет интерфейс Alpha. Какой
вариант метода с реализацией по умолчанию используется в этом случае? А что
если в классе MyClass предоставляется собственная реализация этого метода?
Для ответа на эти и другие аналогичные вопросы в Java определен **ряд правил разрешения**
**подобных конфликтов**.

**Во-первых**, во всех подобных случаях приоритет отдается реализации метода
в классе над его реализацией в интерфейсе. Так, если в классе MyClass переопределяется
метод с реализацией по умолчанию reset ( ) , то выбирается его вариант,
реализуемый в классе MyClass. Это происходит даже в том случае, если в классе
MyClass реализуются оба интерфейса, Alpha и Beta. И это означает, что методы
с реализацией по умолчанию переопределяются их конкретной реализацией
в классе MyClass.

**Во-вторых**, если в классе используются два интерфейса с одинаковым реализуемым
по умолчанию методом, но этот метод не переопределяется в данном классе,
то возникает ошибка. Если же в классе MyClass реализуются оба интерфейса,
Alpha и Beta, но метод reset () в нем не переопределяется, то и в этом случае
возникает ошибка.

**В тех случаях**, когда один интерфейс наследует другой и в обоих интерфейсах
определяется общий метод с реализацией по умолчанию, предпочтение отдается
варианту метода из наследующего интерфейса. Так, если интерфейс Beta расширяет
интерфейс Alpha, то используется вариант метода reset () из интерфейса Beta. Впрочем, используя особую форму ключевого слова super, вполне возможно ссылаться на реализацию по умолчанию в наследуемом интерфейсе. Эта общая
форма ключевого слова super выглядит следующим образом:
		имя_интерфейса.suреr.имя_метода()
Так, если из интерфейса Beta требуется обратиться по ссылке к методу с реализацией
по умолчанию reset () в интерфейсе Alpha, то для этого достаточно
воспользоваться следующим оператором:
		Alpha.super.reset();




