Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-07-31T21:18:49+03:00

====== Generic ======
Created Wednesday 31 July 2019

**Generic (Обобщение):**
	class Cl<T>{
		T o;
		Cl(){ o = new T(); }
		Cl(T o){ this o = o; }
		T getObj(){
			return o;
		}
		void typeShow(){
			System.out.println("Type = " + o.getClass().getName());
		}		
	}
	class Main{
		var o = new Cl<Integer>(88);
		o.typeShow();
	}
Теперь тип Т можно применять везде, где применим тип - объявление полей, локальных переменных, типов возвращаемых методом значений, типом аргумента метода.

**Через запятую можно задать несколько типов-обобщений:**
	class Cl<T, V>{ . . . } //для каждого такого типа-обобщения применимы описанные далее усложнения

**Типами обобщений могут быть только ссылочные типы (не примитивные).** При надобности - используем оболочки (не int, а Integer). Джавкины оболочки имеют хороший (? смотреть) механизм автоупаковки и автораспаковки.

**Ссылки на объекты обобщенных типов, для которых заданы различные параметры-типы, - не совместимы.** Т.е.:
		var o1 = new Cl<Integer>(88);		
		var o2 = new Cl<Double>("Abra");
		o1=o2; //Error

				//(Можно построить алгоритм без обобщений, основываясь на общем Object. Компилятор даже автоопределит тип аргуметов и автообернет их в правильную обертку, сохраняя далее в 'o', но при возврате такого объекта понадобится ручное приведение его типа://
				//		int i = <Intreger> o1.getObj;//
				//		String s = <String> o2.getObj;//
				//но компиляцию пройдет и так://
				//		int i = <Integer> o2.getObj; // где на самом деле "Abra", вызовет Runtime Error//
				//Следовательно, ручной подход типоопасен, а обобщение - более типобезопасно.)//

**Ограниченное обобщение (<Т extends суперкласс>):**
через extends можно указать компилятору какуе подмножество типов может принимать обобщение, - например, все типы наследуют Object, но только численные наследуют Number, поэтому дженерик вида <T extends Number> ограничит возможные обобщения только числовыми типами (ограничение сверху - режем ветвь, т.е. разрешенниые типы, это Number и все его наследники). Таким образом гарантируется, что другие типы, например String, в обобщение подставлены не будут. (Теперь, например, ограничив подмножество типов классом Number, можем смело применять к типу метод Number-класса doubleValue(), позволяющеий любое число вернуть приведенным в double).
	class Stats<T extends NumЬer> { ... }
В виде ограничения можно использовать не только тип класса, но и тип интерфейса. Более того, такое ограничение может включать в себя как тип класса, так и типы одного или нескольких интерфейсов. В этом случае тип класса должен быть задан первым. Для их объединения служит символ логической операции &:
	class Gen<T extends MyClass & Myinterface> { //
Здесь параметр типа T ограничивается классом MyClass и интерфейсом Myinteface. Таким образом, любой тип, передаваемый параметру Т, должен быть подклассом, производным от класса MyClass и реализующим интерфейс Myinteface.

**Ограничение обобщения классом с ограниченным обобщением (вложенные обобщения):**
class ClassGen<T extends Comparable<T>, V extends T>{ . . . } //Обобщение Т типом, ограниченным интерфейсом (здесь) Comparable, ограниченным типом Т, и обобщение V-типом, ограниченным Т-типом

**Метасимвольный аргумент - "?" - как "любой тип":**
	Смотрим пример как можно сравнить средние арифметические значения для массивов разных типов, но подтипа Number (с учетом doubleValue(), про что было выше):
	class Stats<T extends Number> {
		Т[] nums;
		Stats(T[] о) {nums = о;}
		double average() {
			double sum = О.О;
			for(int i=O; i < nums.length; i++) sum += nums[i] .doubleValue();
			return sum / nums.length;
		}
		boolean sameAvg(Stats<?> оb) { //тут - любой тип*
			if(average() == ob.average()) return true;
			return false;
		}
*- именно "любой", т.е. extends-ограничение на него не распространилось. 

**Для ограничения метасимвола существует понятие "Ограниченный метасимвольный аргумент" вида "Stats<? extends Number> оb"**, т.е.:
		boolean sameAvg(Stats<? extends Number> оb) { //тут - любой тип подмножества Number
			if(average() == ob.average()) return true;
			return false;
		}
Таким образом, оператор extends налагает ограничение сверху на совпадение с метасимволом "?".
Ограничивать метасимвольный аргумент важно при создании обобщенного типа, оперирующего выделенной иерархией классов.
(Му - compil - по идее "?" может просто знать об extends, заданном в заголовке класса. Либо же, если возможность получить любой класс все же необходима (см. Обобщенный метод" ниже), неплохо бы завести иной символ, например "??", который знает об extends).

**Обобщенный метод**
Вне зависимости от того, обобщен класс или нет, имеет право на существование обобщенный метод с следующим, несколько сложноватым синтаксисом:
	class GenMethDemo {
		static <Т extends Comparable<T>, V extends Т> boolean isIn(T х, V[] у) { //содержит ли массив указанное число?
			for(int i=0; i < y.length; ++i) {
				if(x.equals(y[i])) return true;
			}
			return false;
		}
		. . .
	}
Обобщенные методы могут быть как статическими, так и нестатически­ми.
Видим, что параметр типа объявляется до типа, возвращаемого методом. Обратите так­же внимание на то, что тип Т расширяет обобщенный тип Comparable<T>, где Comparable - это интерфейс, объявляемый в пакете java. lang. В классе, реа­лизующем интерфейс ComparaЫe, определяются объекты, которые могут быть упорядочены. Следовательно, указание интерфейса Comparable в качестве верх­ней границы гарантирует, что метод isIn() вполне применим к объектам, кото­рые можно сравнивать.
Интерфейс Comparable является обобщенным, а пара­метр его типа обозначает тип сравниваемых объектов. (Далее будет показано, как создается обобщенный интерфейс.) Обратите внимание на то, что тип V ограничен сверху ТАКЖЕ типом T. Это означает, что тип V должен быть тем же ти­пом, что и Т, или же типом его подкласса. **Такая взаимосвязь подразумевает, что метод isIn () может быть вызван только с совместимыми аргументами.** Это гарантирует, что вызов вида  if(isin("двa", nums)) компилятор не пропустит.

А вот синтаксис вызова такого метода может быть простым до нельзя:
	public static void main(String args[]) {
		Integer nums [] = { 1, 2, 3, 4, 5 } ;
		if(isIn(2, nums)) System.out.println("Чиcлo 2 содержится в массиве nums");
		String strs[] = {"один", "два", "три", "четыре", "пять"};
		if(isIn("двa", strs)) System.out.println("два содержится в массиве strs");
	}
Т.е. обычный синтаксис вызова, без требования указывать аргументы типа. Дело в том, что выведение типов выполняется автоматически, а типы Т и V соот­ветственно подстраиваются. Например, в первом вызове этого метода. if(isin(2, nums)) первый аргумент относится к типу Integer (благодаря автоупаковке), поэтому вме­сто типа Т подставляется тип Integer. Второй аргумент также относится к типу Integer, который подставляется вместо типа V. Во втором вызове данного метода оба аргумента относятся к типу String, который и подставляется вместо типов Т и V. Для вызовов большинства обобщенных методов, как правило, достаточно и вы­ведения типов, но если требуется, то аргументы типа можно указать явно синтаксисом:
	GenMethDemo.<Ineger, Integer>isIn(2, nums);
Но указывать аргументы типа явным обра­зом требуется лишь в крайне редких случаях.

**Обобщенные конструкторы**
Конструктор может быть обобщенным, в т.ч. если класс не обобщен. Параметр типа также объявляется до имени конструктора.
	class GenCons {
		<Т extends Number> GenCons(T arg) {
			val = arg.doubleValue();
		}
	}

**Обобщенный интерфейс**
Объявление аналогично классу. 
	interface MinMax<T extends Comparable<T>> {
		Т min();
		Т max();
	}
(интерфейс Comparable определен в пакете java.lang для целей сравнения объектов.)

Реализуем обобщенный интерфейс MinMax:
	class MyClass<T extends Comparable<T>> implements MinMax<T> { //т.е. в implements не нужно повторять ограничение
		public Т min() { for ...} //реализация
		public T max() { for ...} //реализация
		...
	}

Используем:
	class GenIFDemo {
		public static void main(String args[]){
			Integer inums[] {3, 6, 2, 8, 6 };
			Character chs [] = { 'b' , 'r' , 'р' , 'w' } ;

			MyClass<Integer> iob = new MyClass<Integer>(inums);
			MyClass<Character> соb = new MyClass<Character>(chs);
			System.out.println("Maкcимум в inums: " + iob.max());
			System.out.println("Maкcимум в chs: " + cob.max());
		}
	}

Как правило, класс, реализующий обобщенный интерфейс, должен быть также обобщенным - по крайней мере, в тех случаях, когда он принимает параметр типа, передаваемый далее интерфейсу. Например, следующая попытка объявить класс MyClass приведет к ошибке:
		class MyClass implements MinMax<T> { //Неверно!
В классе MyClass параметр типа не объявляется, поэтому передать его интерфейсу MinMax невозможно.
Но если класс реализует конкретный тип обобщенного интерфейса, то реализующий класс не обязан быть обобщенным:
		class MyClass implements MinMax<Integer> { //Верно
Обобщенный интерфейс дает два преимущества:
	- он может быть реализован для разных типов данных;
	- он позволяет наложить ограничения на типы данных, для которых он может быть реализован.
В примере интерфейса MinMax вместо параметра типа Т могут быть подставлены только типы классов, реализующих интерфейс Comparable.

**Базовые типы и унаследованный код**
440

<? super Number> "любой тип, являющийся супер-классом для Number"



