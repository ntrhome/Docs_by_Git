Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-06-24T02:56:51+03:00

====== my ======
Created Понедельник 24 июня 2019

= = = = = = = = = = = = = =class
		class Box{...}; //java
или так: type Box{...};
		Вох x = new Вох(3, "hello"); //java
или так: Вох (3, "hello")x, y, ()y, *z = &x; // [z]. и блин никаких "->"
и возвращать конструктор должен ссылку на созданный им объект, а не ничего.


объект - конкретный кусок памяти, идентифицируемый типом и начальным адресом, в котором расположен экземпляр класса. 

x, y - имя объекта, асоциированное с его идентификатором (адрес + тип) для простого оперирования в языке.

y = x; //в кусок памяти, именованный y скопировали кусок памяти, именованный x (при условии, что тип идентичен).

идентичность типа - понятие растяжимое. Логична присказка про утку.

& - оператор разименования - т.е. взятие идентификатора (адрес + тип) для операции назначения псевдонима или операции присвоения указателю.

auto &q = &x; // операция назначения псевдонима q для x.

z = &x; // операция присвоения указателю идентификатора на x.

указатель - место в памяти, предназначенное для хранения идентификатора объекта (адрес вписывается в место памяти, а тип отслеживается компилятором).

x.member - доступ к члену через имя объекта.

[z].member - доступ к члену через указатель на объект.

*a, *b[10] int; // a и b - указатели на int, причем b - на массив из 10 int

int *a - объявление указателя на int, причем скорее всего на статическую последовательность (массив) int (никаких int a[] - присказка: то что может быть сделано - делается единственным способом).

a = new int; a = int[10]; a int[10];

Перегрузка метода - различать перегрузку хорошо бы и по возврвщаемому типу - это удобно (шаблонить и расширять), другое дело, что язык должен делать это уверенно, в т.ч. автоприведение типов либо исключается вообще, либо очень контролиоовано, и еще, когда забрать результат не хотят, то подставляется либо единственная для перегрузки с void, либо еррор. НО!!! что потом делать с "auto value = f();"? - предлагаю такое забанить, не на столько уж оно полезно, и вообще, если строгая типизация, то "auto" идет в жертву. Однако ценность перегрузки по типу возвращаемого значения сложно переоценить - это можно вообще отдать на откуп языку, возможно ограничивая его явно при необходимости: хочешь, результат в int, хочешь - строка, хочешь, объект (например не int а обертка Integer), хочешь - boolean (0, !0)... Т.е., как минимум конверт стандартных типов (примитивных и stdlib), хотя лучше бы расширить на любые выводы, определив общие правила.) Но возможно теряем контроль и однозначность - "так что же собственно вернулось?" Можно компромисным путем - конверт как указано, но прописывается с явным постфиксом вида: "f(9.99).str(); f(9.99).int(); f(9.99).dbl(); ..." или "str.f(9.99); int.f(9.99); dbl.f(9.99); ..." **А может и нет никакой ценности - метод отработал и выдал единственно верный свой пезультат, а его интерпретация, это вопрос получателя - всем не угодишь!**

констукции try ужасны, отлавливание ошибок сделать человеческим (может по механизму события или оповещения, если оповещение пошло, должно вернуться (если нет обработчика, то как минимум от системы, тогда или ресуме - метка "вернуться и повторить попытку" либо выйти с ерором (если предусмотренно), либо продолжить (обработчик сам все сделал).


= = = = = = = = = = = = = =
фабрика - продуцируем  объекты и выпускаем наволю?
= = = = = = = = = = = = = =
= = = = = = = = = = = = = =
= = = = = = = = = = = = = =
= = = = = = = = = = = = = =
= = = = = = = = = = = = = =
