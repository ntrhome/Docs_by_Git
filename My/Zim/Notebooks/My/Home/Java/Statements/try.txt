Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-06-17T23:07:16+03:00

====== try ======
Created Понедельник 17 июня 2019

https://habr.com/ru/company/golovachcourses/blog/223821/

(дальше - Механизм try - это "механизм исключений").

**Ключевые слова:**
	**try, **
	**catch, **
	**finally, **
	**throw, **
	**throws**
	
**Описание:**
	**try** {
		// блок кода, в котором отслеживаются ошибки.
		// Исключения могут генерироваться как пользователем - командой **throw**, 
		// (причем швырнуть можно только объект семейства Throwable),
		// так и системой;
	}
	**catch** (тип_исключения_1 ехObj) {
		// обработчик исключений для тип_исключения_1.
		// Причем если исключение не ловит текущая конструкция try, 
		// то оно может быть перехвачено во внешней объемлющей конструкции try.
	}
	...
	**catch** (тип_исключения_N ехObj) {
		// обработчик исключений для тип_исключения_N.
	}
	**finally** {
		// блок кода, который непременно выполняется в конце отработки try,
		// даже если выше встречен return,
		// кроме только случая остановки JVM, например по вызову:
		//	- **System.exit(0);**  0, 42 ... - неважно
		//	- **Runtime.getRuntime().exit(42);**  синоним System.exit(42);
		//	- **Runtime.getRuntime().halt(42);**
	}

**"Швыряемыми" могут быть только наследники (объекты-исключения семейства ..) java.lang.Throwable **(т.е. объект например типа String швырнуть нельзя):
	Иерархия исключений:
							 Object
								 |
							Throwable
							/           \
						Error     Exception
											|
									RuntimeException

	Класс **Exception** служит для исключительных условий, которые должна перехватывать прикладная программа. Именно от этого класса вам и предстоит наследовать свои подклассы при создании собственных типов исключений. У класса Exception имеется важный подкласс - RuntirneException. Исключения этого типа автоматически определяются для создаваемых вами прикладных программ и охватывают такие ошибки, как деление на нуль и ошибочная индексация массивов.
	
	Класс **Error** используются в исполняющей системе Java для обозначения ошибок, происходящих в самой исполняющей среде. Примером такой ошибки может служить переполнение стека. Они, как правило, возникают в связи с аварийными сбоями, которые не могут быть обработаны в прикладной программе.

	__И с null'ом тут разобраться, - швырнуть просто null нельзя, а вот швырнуть переменную-ссылку типа java.lang.Throwable, которая равна null, - можно. Понимаю так: простой null принимается как (Object) null, а надо (java.lang.Throwable) null.__

**Стандартный обработчик:**
	Любое исключение, не перехваченное прикладной программой, в конечном итоге будет перехвачено и обработано **стандартным обработчиком** среды Java. Стандартный обработчик выводит символьную строку с описанием исключения и результат трассировки стека, начиная с момента возникновения исключения, а затем прерывает выполнение программы. Например для кода:
	class Ехс0 {
				public static void main(String args[]) {
					int d = 42/0;
				}
			}
**Трассировка:**
	будет выведена трассировка:
			Exception in thread "main" java.lang.ArithmeticException: / by zero
			at Exc0.main(Exc0.java:3)
	(в потоке 'main', классе Ехс0, методе main(), файла Ехс0.java, в строке 4 сгенерированно исключение типа java.lang.ArithmeticException с уточнением: "/ by zero". Если исключение генерировано в подметоде, то трассировка покажет весь стек вызовов подметодов, приведший к исключению - от метода-виновника до main).
**Перехват исключения "деление на 0":**
	Ловим это деление на 0:
			try { //проконтролировать блок кода
					int d = 42/0;
					System.out.println("Этo не будет выведено."); 
			} catch (ArithmeticException е) {
					//перехват ошибки деления на нуль
					System.out.println("Дeлeниe на нуль.");
			}
			System.out.println("Прыг пocлe оператора catch.");
	выдаст:
			Деление на нуль.
			Прыг после оператора catch.

**Повторное выполнение кода в случае исключения:**
	Обычно для повторного выполнения кода в случае исключения, этот код вводится в цикл (while ..), выполняемый до получения удовлетворительного решения или явного принудительного выхода.

	Классы-исключения предоставляют свои поля и методы...
	
**Механизм try использует System.err, а не System.out:**
	Помним, что System.out - buffered-поток вывода, а System.err - нет, и при выполнении кода:
			public static void main(String[] args) {
					System.out.println("sout");
					throw new Error();
			}
	вполне может быть получен вывод, где err обогнало out:
			>> RUNTIME ERROR: Exception in thread "main" java.lang.Error
			>> sout
	(И не пучим глаза при отладке).
	(Сами пользуем System.err.println(...); )

**Механизм try в некоторых случаях может позволять методу ничего не возвращать, хотя должен (например, когда возвращать в принципе нечего, а спец-значение "ничего" не применяется - прерываем выполнение):**
		public static double f(double arg) {
				if(...) 
						throw new RuntimeException();
				else {...}
		}

**Помнить, что швыряя исключение мы прерываем выполнение стека переходов, будет т.е. не:**
	- to A
		- - to B
			(return;)
		- - from B
	- from A
**а будет:**
	- to A
		- - to B
			(throw new Error();)
	- - - - - - -.

**При этом catch останавливает вылет из стека переходов:**
	- to A
		- - to B
			(throw new Error();)
		- -  - - -
		catch (Error e){...} //тут обрабатывааем, и из А выйдем уже культурно
	- from A

**Вложенный try:**
	Конструкции try могут быть вложенными - непосредственно, либо путем вызова в блоке try метода, который сам содержит блок try. Именно в этом случае перехват исключений можно организовать в иерархии конструкций try, только по выходу из которой будет задействован системный обработчик.
	
**Вложенный throw:**
	Если в блоке catch будет снова встречен throw, то это новое исключение (не важно какое) прерывает выполнение блока catch, и не имея к нему отношения должно быть обработано внешним try-catch (т.е. вылет из стека переходов продолжится).
	
**Порядок следования типов в catch:**
	ЕСЛИ НАДО (иногда в одном участке кода может возникнуть несколько исключений), конструкция try позволяет расположить несколько cach (будут обрабатываться сверху вниз), но придерживаясь правила: нельзя ловить передка, а потом потомка объекта-исключения - оба будут пойманы на предка (причем типы проверяются по динамическому связыванию - в рантайме).
			try {
			} catch (Exception e) { //нельзя: Exception поймает и Exception и RuntimeException
			} catch (RuntimeException e) {//сюда дело бы никогда не дошло (но выдаст COMPILATION ERROR)
			}
	Брата после брата - ставить можно. Они разные.
	**Не забываем:**
	Catch - полиморфная конструкция, перехватывающая летящий объект любого подтипа-исключения, но если он лежит в иерархии наследования не раньше ловимого типа!!! (Т.е. например тип Exception поймает RuntimeException, но не поймает Throwable или Error). Иначе catch его не ловит, и вылет из стека переходов продолжается.

**finally:**
	finally-секция получает управление всегда как только завершилось выполнение try-блока, и неважно как завершилось - успешно (включая ситуацию если встречен return), или не успешно и вызвано исключение.
			try {
				System.err.println("try");
			} finally {
					System.err.println("finally");
			}
	finally-секция не будет выполнена только в одном случае - если в try была прекращена работа JVM:
		- по вызову exit: System.exit(0); System.exit(42); (Runtime.getRuntime().exit(42); - синоним);
		- по вызову halt: Runtime.getRuntime().halt(42);
	Halt, в отличие от exit, вываливает из JVM сразу, не ожидая выполнения финализаторов (?, здесь не имеется в виду finally от try, думаю говорится о другом механизме), которые уместны у exit.

**if (true) {throw new RuntimeException();}** - конструкция применяется если мы хотим вдруг влепить вызов исключения, а компилятор ругается, что дальнейший код недостижим.

**Вывод сообщения в своем классе исключения:** 
	организуется путем переопределения метода toString() (определенного в Throwable). Сообщение можно вывести с помощью print просто передав ему объект-исключение.
	
- - - - - - - - - -
Существует особая форма оператора try, обеспечивающая автоматическое управление
ресурсами. Эта форма называется оператором tryc ресурсами и подробнее рассматривается
в главе 1 З в контексте управления файлами, поскольку файлы относятся к наиболее часто
используемым ресурсам.













