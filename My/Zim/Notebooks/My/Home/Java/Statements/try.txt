Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2019-06-17T23:07:16+03:00

====== try ======
Created Понедельник 17 июня 2019

https://habr.com/ru/company/golovachcourses/blog/223821/

(дальше - Механизм try - это "механизм исключений").

**Ключевые слова:**
	**try, **
	**catch, **
	**finally, **
	**throw, **
	**throws**
	
**Описание:**
	**try** {
		// блок кода, в котором отслеживаются ошибки.
		// Исключения могут генерироваться как пользователем - командой **throw**, 
		// (причем швырнуть можно только объект семейства Throwable),
		// так и системой;
	}
	**catch** (тип_исключения_1 ехObj) {
		// обработчик исключений для тип_исключения_1.
		// Причем если исключение не ловит текущая конструкция try, 
		// то оно может быть перехвачено во внешней объемлющей конструкции try.
	}
	...
	**catch** (тип_исключения_N ехObj) {
		// обработчик исключений для тип_исключения_N.
	}
	**finally** { //секция finally идет не раньше секции catch (но секции catch может и не быть)
		// блок кода, который непременно выполняется в конце отработки try,
		// даже если выше встречен return,
		// кроме только случая остановки JVM, например по вызову:
		//	- **System.exit(0);**  0, 42 ... - неважно
		//	- **Runtime.getRuntime().exit(42);**  синоним System.exit(42);
		//	- **Runtime.getRuntime().halt(42);**
	}
	finally-секция не обязательна, но либо секция catch либо секция finally в блоке try должна присутствовать.
	
**"Швыряемыми" могут быть только наследники (объекты-исключения семейства ..) java.lang.Throwable **(т.е. объект например типа String швырнуть нельзя):
	Иерархия исключений:
							 Object
								 |
							Throwable
							/         \
						Error     Exception
											|
									RuntimeException

	Класс **Exception** служит для исключительных условий, которые должна перехватывать прикладная программа. Именно от этого класса вам и предстоит наследовать свои подклассы при создании собственных типов исключений. У класса Exception имеется важный подкласс - RuntirneException. Исключения этого типа автоматически определяются для создаваемых вами прикладных программ и охватывают такие ошибки, как деление на нуль и ошибочная индексация массивов.
	
	Класс **Error** используются в исполняющей системе Java для обозначения ошибок, происходящих в самой исполняющей среде. Примером такой ошибки может служить переполнение стека. Они, как правило, возникают в связи с аварийными сбоями, которые не могут быть обработаны в прикладной программе.

	__И с null'ом тут разобраться, - швырнуть просто null нельзя, а вот швырнуть переменную-ссылку типа java.lang.Throwable, которая равна null, - можно. Понимаю так: простой null принимается как (Object) null, а надо (java.lang.Throwable) null.__

**Стандартный обработчик:**
	Любое исключение, не перехваченное прикладной программой, в конечном итоге будет перехвачено и обработано **стандартным обработчиком** среды Java. Стандартный обработчик выводит символьную строку с описанием исключения и результат трассировки стека, начиная с момента возникновения исключения, а затем прерывает выполнение программы. Например для кода:
	class Ехс0 {
				public static void main(String args[]) {
					int d = 42/0;
				}
			}
**Трассировка:**
	будет выведена трассировка:
			Exception in thread "main" java.lang.ArithmeticException: / by zero
			at Exc0.main(Exc0.java:3)
	(в потоке 'main', классе Ехс0, методе main(), файла Ехс0.java, в строке 4 сгенерированно исключение типа java.lang.ArithmeticException с уточнением: "/ by zero". Если исключение генерировано в подметоде, то трассировка покажет весь стек вызовов подметодов, приведший к исключению - от метода-виновника до main).
**Перехват исключения "деление на 0":**
	Ловим это деление на 0:
			try { //проконтролировать блок кода
					int d = 42/0;
					System.out.println("Этo не будет выведено."); 
			} catch (ArithmeticException е) {
					//перехват ошибки деления на нуль
					System.out.println("Дeлeниe на нуль.");
			}
			System.out.println("Прыг пocлe оператора catch.");
	выдаст:
			Деление на нуль.
			Прыг после оператора catch.

**Повторное выполнение кода в случае исключения:**
	Обычно для повторного выполнения кода в случае исключения, этот код вводится в цикл (while ..), выполняемый до получения удовлетворительного решения или явного принудительного выхода.

	Классы-исключения предоставляют свои поля и методы...
	
**Механизм try использует System.err, а не System.out:**
	Помним, что System.out - buffered-поток вывода, а System.err - нет, и при выполнении кода:
			public static void main(String[] args) {
					System.out.println("sout");
					throw new Error();
			}
	вполне может быть получен вывод, где err обогнало out:
			>> RUNTIME ERROR: Exception in thread "main" java.lang.Error
			>> sout
	(И не пучим глаза при отладке).
	(Сами пользуем System.err.println(...); )

**Механизм try в некоторых случаях может позволять методу ничего не возвращать, хотя должен (например, когда возвращать в принципе нечего, а спец-значение "ничего" не применяется - прерываем выполнение):**
		public static double f(double arg) {
				if(...) 
						throw new RuntimeException();
				else {...}
		}

**Помнить, что швыряя исключение мы прерываем выполнение стека переходов, будет т.е. не:**
	- to A
		- - to B
			(return;)
		- - from B
	- from A
**а будет:**
	- to A
		- - to B
			(throw new Error();)
	- - - - - - -.

**При этом catch останавливает вылет из стека переходов:**
	- to A
		- - to B
			(throw new Error();)
		- -  - - -
		catch (Error e){...} //тут обрабатывааем, и из А выйдем уже культурно
	- from A

**Вложенный try:**
	Конструкции try могут быть вложенными - непосредственно, либо путем вызова в блоке try метода, который сам содержит блок try. Именно в этом случае перехват исключений можно организовать в иерархии конструкций try, только по выходу из которой будет задействован системный обработчик.
	
**Вложенный throw:**
	Если в блоке catch будет снова встречен throw, то это новое исключение (не важно какое) прерывает выполнение блока catch, и не имея к нему отношения должно быть обработано внешним try-catch (т.е. вылет из стека переходов продолжится).
	
**Порядок следования типов в catch:**
	ЕСЛИ НАДО (иногда в одном участке кода может возникнуть несколько исключений), конструкция try позволяет расположить несколько cach (будут обрабатываться сверху вниз), но придерживаясь правила: нельзя ловить передка, а потом потомка объекта-исключения - оба будут пойманы на предка (причем типы проверяются по динамическому связыванию - в рантайме).
			try {
			} catch (Exception e) { //нельзя: Exception поймает и Exception и RuntimeException
			} catch (RuntimeException e) {//сюда дело бы никогда не дошло (но выдаст COMPILATION ERROR)
			}
	Брата после брата - ставить можно. Они разные.
	**Не забываем:**
	Catch - полиморфная конструкция, перехватывающая летящий объект любого подтипа-исключения, но если он лежит в иерархии наследования не раньше ловимого типа!!! (Т.е. например тип Exception поймает RuntimeException, но не поймает Throwable или Error). Иначе catch его не ловит, и вылет из стека переходов продолжается.

**finally:**
	**finally-блок получает управление ВСЕГДА в момент перед выходом из try-catch блока (за исключением выхода с остановкой VM по exit или halt - см. ниже).** И неважно где (в секции try или секции catch) и как выполняется выход: 
		- блок try успешно выполнен и осуществляется выход из его секции:
			- - на следующую за try-блоком инструкцию;
			- - по return в вызывающий код;
			- - по break метка;
		- в блоке try генерировано (или пролетает из вызванного кода) неперехватываемое здесь исключение (типа Error или RuntimeException), тогда finally выполняется сразу при обработке такого throw (или места прилета - со строчки вызова приславшего метода);
		- в блоке try генерировано перехватываемое здесь исключение (включая перебрасываемое), тогда finally выполняется сразу по выходу (неважно как) из блока catch.

	Зачем? Если код завершен по исключению, то кодом могут остаться невыполненными некоторые обязательные завершающие действия (в основном - высвобождение ресурсов).

			try {
				System.err.println("try");
			} finally {
					System.err.println("finally");
			}
			
	**finally-секция не будет выполнена только в одном случае** - если в try была прекращена работа JVM:
		- по вызову exit: System.exit(0); System.exit(42); (Runtime.getRuntime().exit(42); - синоним);
		- по вызову halt: Runtime.getRuntime().halt(42);
	Halt, в отличие от exit, вываливает из JVM сразу, не ожидая выполнения финализаторов (?, здесь не имеется в виду finally от try, думаю говорится о другом механизме), которые уместны у exit.

**if (true) {throw new RuntimeException();}** - конструкция применяется если мы хотим вдруг влепить вызов исключения, а компилятор ругается, что дальнейший код недостижим.

**Вывод сообщения в своем классе исключения:** 
	организуется путем переопределения метода toString() (определенного в Throwable). Сообщение можно вывести с помощью print просто передав ему объект-исключение.

**Оператор throws**
	Если метод способен вызвать исключение, которое сам не обрабатывает, он должен сообщить о таком возможном поведении (цель - известить вызывающий его код). С этой целью в объявление метода вводится оператор throws и через запятую перечисляются типы таких исключений. __Это обязательно для всех исключений (т.н. "проверяемых"), кроме классов Error и RuntimeException или их подклассов (т.н. "непроверяемых" - необязательно вносить в throws). Иначе ошибка компиляции.__
			тип имя_метода(список_параметров) throws список_исключений { //тело метода }
	__С другой стороны, вызывающий код обязан делать это из блока try и обрабатывать эти исключения. Иначе ошибка компиляции.__
	Если непосредственно вызывающий код не желает обработать полученные из метода исключения, он обязан передать их для обработки на уровень кода выше. Для этого он должен сделать 2 вещи: 
	1) объявить эти исключения в своем throws;
	2) поймать его в своей конструкции try-catch и перешвырнуть бай throw на уровень выше.


**Встроенные в Java исключения**
	В стандартном пакете java.lang определен ряд классов исключений.
	Большинство из них - семейства стандартного RuntimeException (непроверяемые - необязательно вносить в throws), например:
			ArithmeticException Арифметическая ошибка (например, деление на нуль) 
			ArrayindexOutOfBoundsException Выход индекса за пределы массива
			ClassCastException Неверное приведение типов
			NullPointerException Неверное использование пустой ссылки
			...
	Но есть и другие, включая проверяемые (те, которые обязательно вносят в throws), например (проверяемые):
			InstantiationException Попытка создать объект абстрактного класса или интерфейса
			NoSuchМethodException Запрашиваемый метод не существует
			...

**Создание собственного подкласса исключений**
	Чтобы создать класс собственного исключения, достаточно определить его как производный от класса Exception, который, в свою очередь, является производным от класса Throwabe. 
	В подклассах собственных исключений совсем не обязательно реализовать что-нибудь. Их присутствия в системе типов уже достаточно, чтобы пользоваться ими как исключениями.
	
	В самом классе Exception не определено никаких методов. Но он наследует методы из класса Throwable. Таким образом, всем классам исключений, в том числе и создаваемым самостоятельно, доступны [[https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Throwable.html|методы, определенные в классе Throwable]] (13 шт.) И их можно переопределить в своем подклассе (не все - есть final):
			void addSuppressed​(Throwable exception) - добавить исключение в список подавляемых исключений.
			Throwable fillInStackTrace() - вернуть полную трассировку стека.
			Throwable getCause() - вернуть исключение, базовое для текущего исключения.
			String getLocalizedMessage() - возвращает локализованное описание исключения.
			String getMessage() - возвращает описание исключения.
			StackTraceElement[] getStackTrace() - возвращает массив, содержащий поэлементную трассировку стека.
			Throwable[] getSuppressed() - получает массив подавленых исключений.
			Throwable initCause​(Throwable cause) - связывает причину_исключения с вызывающим исключением.
			void printStackTrace() - выводит трассировку стека.
			void printStackTrace​(PrintStream s) - направляет трассировку стека в заданный поток вывода (PrintStream).
			void printStackTrace​(PrintWriter s) - направляет трассировку стека в заданный поток вывода (PrintWriter).
			void setStackTrace​(StackTraceElement[] stackTrace) - устанавливает трассировку стека для заданных эленентов (СПЕЦИАЛЬНОЕ применентие).
			String toString() - возвращает String, содержащий описание исключения.

	В классе Exception определяются четыре открытых конструктора.
			- первые два конструктора поддерживают цепочки исключений (см. дальше),
			- -//-
			а два других:
			- Exception ()
			- Exception(String описание) //можно задать описание (будет выводить имя исключения, затем двоеточие, затем описание исключения), иначе можно переопределить toString() (будет выводить заданную строку).
			Например:
				class MyException extends Exception {
					private int detail;
					MyException(int а) { detail = а; } //конструктор
					public String toString() { return "MyException [" + detail + "]"; } //переопределенный toString ()
				}
				class ExceptionDemo {
					static void compute(int а) throws MyException {
						System.out.println("Bызвaн метод compute("+ а +")");
						if(a > 10) throw new MyException(a);
						System.out.println("Hopмaльнoe завершение");
					}
					public static void main(String args[J) {
						try {
							compute(l);
							compute (20);
						} catch (MyException е) {
							System.out.println("Пepexвaчeнo исключение: " + е);
						}
					}
				}
- - - - - - - - - -
__Существует особая форма оператора try, обеспечивающая автоматическое управление__
__ресурсами. Эта форма называется оператором tryc ресурсами и подробнее рассматривается__
__в главе 1З в контексте управления файлами, поскольку файлы относятся к наиболее часто__
__используемым ресурсам.__













