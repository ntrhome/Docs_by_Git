hackerrank
https://leetcode.com/ - больше на алгоритмы
https://javarush.ru/groups/posts/549-java-zadachi-s-podvokhom-privet-sobesedovanija#zadacha2
https://javarush.ru/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java
https://javarush.ru/groups/posts/458-key-khorstmann-i-ego-1500-slov-o-tom-kak-statjh-luchshim-java-programmistom--
	Вначале «втяните» базовые языковые конструкции в свое подсознание, то есть доведите их знание до автоматизма путем решения большого числа упражнений.
	Как можно быстрее приступите к работе над реальными проектами, интересными вам.
	Затем присоединитесь к сообществу, где вы можете задавать вопросы и отвечать на них.
	Как только вы это сделаете, на собеседованиях вы сможете говорить со знанием дела и опытом. И не так уж и важно, решите ли вы надуманную головоломку.


Class - Generic (Обобщение)
	class Cl<T>{
		T o;
		Cl(){ o = new T(); }
		Cl(T o){ this o = o; }
		T getObj(){
			return o;
		}
		void typeShow(){
			System.out.println("Type = " + o.getClass().getName());
		}		
	}
	class Main{
		var o = new Cl<Integer>(88);
		o.typeShow();
	}

	Типами обобщений могут быть только ссылочные типы (а не примитивные). При надобности - используем оболочки (не int, а Integer). Джавкины оболочки имеют хороший (? смотреть) механизм автоупаковки и автораспаковки.

	Ссылки на объекты обобщенных типов, для которых заданы различные параметры-типы, - не совместимы. Т.е.:
		var o1 = new Cl<Integer>(88);		
		var o2 = new Cl<Double>("Abra");
		o1=o2; //Error

	Можно построить алгоритм без обобщений, основываясь на общем Object. Компилятор даже автоопределит тип аргуметов и автообернет их в правильную обертку, сохраняя далее в 'o', но при возврате такого объекта понадобится ручное приведение его типа:
		int i = <Intreger> o1.getObj;
		String s = <String> o2.getObj;
	но компиляцию пройдет и так:
		int i = <Integer> o2.getObj; // где на самом деле "Abra", вызовет Runtime Error
	Следовательно, ручной подход типоопасен, а обобщение - более типобезопасно.

	Ограниченное обобщение (<Т extends суперкласс>):
	через extends можно указать компилятору какую группу типов может принимать обобщение, - например, все типы наследуют Object, но только численные наследуют Number, поэтому дженерик вида <T extends Number> ограничит возможные обобщения только числовыми типами (ограничение сверху, т.е. разрешенниые типы, это Number и все его наследники). (А Number, например, содержит метод doubleValue(), позволяющее любое число вернуть приведенным в double).  Таким образом гарантируется, что другие типы, например String, в обобщение подставлены не будут.
	class Stats<T extends NumЬer> { ... }
В виде ограничения можно использовать не только тип класса, но и тип интерфейса. Более того, такое ограничение может включать в себя как тип класса, так и типы одного или нескольких интерфейсов. В этом случае тип класса должен быть задан первым. Для их объединения служит символ логической операции &:
	class Gen<T extends MyClass & Myinterface> { //
Здесь параметр типа T ограничивается классом MyClass и интерфейсом Myinteface. Таким образом, любой тип, передаваемый параметру Т, должен быть подклассом, производным от класса MyClass и реализующим интерфейс Myinteface.

427

	

	