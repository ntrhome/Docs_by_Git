hackerrank
https://leetcode.com/ - больше на алгоритмы
https://javarush.ru/groups/posts/549-java-zadachi-s-podvokhom-privet-sobesedovanija#zadacha2
https://javarush.ru/groups/posts/431-10-voprosov-po-abstraktnihm-klassam-i-interfeysam-s-sobesedovaniy-po-jazihku-java
https://javarush.ru/groups/posts/458-key-khorstmann-i-ego-1500-slov-o-tom-kak-statjh-luchshim-java-programmistom--
	Вначале «втяните» базовые языковые конструкции в свое подсознание, то есть доведите их знание до автоматизма путем решения большого числа упражнений.
	Как можно быстрее приступите к работе над реальными проектами, интересными вам.
	Затем присоединитесь к сообществу, где вы можете задавать вопросы и отвечать на них.
	Как только вы это сделаете, на собеседованиях вы сможете говорить со знанием дела и опытом. И не так уж и важно, решите ли вы надуманную головоломку.
GitSCM - git bash for Win


Class - Generic (Обобщение)
	class Cl<T>{
		T o;
		Cl(){ o = new T(); }
		Cl(T o){ this o = o; }
		T getObj(){
			return o;
		}
		void typeShow(){
			System.out.println("Type = " + o.getClass().getName());
		}		
	}
	class Main{
		var o = new Cl<Integer>(88);
		o.typeShow();
	}

	Типами обобщений могут быть только ссылочные типы (а не примитивные). При надобности - используем оболочки (не int, а Integer). Джавкины оболочки имеют хороший (? смотреть) механизм автоупаковки и автораспаковки.

	Ссылки на объекты обобщенных типов, для которых заданы различные параметры-типы, - не совместимы. Т.е.:
		var o1 = new Cl<Integer>(88);		
		var o2 = new Cl<Double>("Abra");
		o1=o2; //Error

(	
Можно построить алгоритм без обобщений, основываясь на общем Object. Компилятор даже автоопределит тип аргуметов и автообернет их в правильную обертку, сохраняя далее в 'o', но при возврате такого объекта понадобится ручное приведение его типа:
		int i = <Intreger> o1.getObj;
		String s = <String> o2.getObj;
	но компиляцию пройдет и так:
		int i = <Integer> o2.getObj; // где на самом деле "Abra", вызовет Runtime Error
	Следовательно, ручной подход типоопасен, а обобщение - более типобезопасно.
)

	Ограниченное обобщение (<Т extends суперкласс>):
	через extends можно указать компилятору какуе подмножество типов может принимать обобщение, - например, все типы наследуют Object, но только численные наследуют Number, поэтому дженерик вида <T extends Number> ограничит возможные обобщения только числовыми типами (ограничение сверху - режем ветвь, т.е. разрешенниые типы, это Number и все его наследники). Таким образом гарантируется, что другие типы, например String, в обобщение подставлены не будут. (Теперь, например, ограничив подмножество типов классом Number, можем смело применять к типу метод Number-класса doubleValue(), позволяющеий любое число вернуть приведенным в double).
	class Stats<T extends NumЬer> { ... }
В виде ограничения можно использовать не только тип класса, но и тип интерфейса. Более того, такое ограничение может включать в себя как тип класса, так и типы одного или нескольких интерфейсов. В этом случае тип класса должен быть задан первым. Для их объединения служит символ логической операции &:
	class Gen<T extends MyClass & Myinterface> { //
Здесь параметр типа T ограничивается классом MyClass и интерфейсом Myinteface. Таким образом, любой тип, передаваемый параметру Т, должен быть подклассом, производным от класса MyClass и реализующим интерфейс Myinteface.


Метасимвольный аргумент - "?" - как "любой тип":
	Смотрим пример как можно сравнить средние арифметические значения для массивов разных типов, но подтипа Number (с учетом doubleValue(), про что было выше):
	class Stats<T extends Number> {
		Т[] nums;
		Stats(T[] о) {nums = о;}
		double average() {
			double sum = О.О;
			for(int i=O; i < nums.length; i++) sum += nums[i] .doubleValue();
			return sum / nums.length;
		}
		boolean sameAvg(Stats<?> оb) { //тут - любой тип*
			if(average() == ob.average()) return true;
			return false;
		}
*- именно "любой", т.е. extends-ограничение на него не распространилось. Для такого ограничения существует понятие "Ограниченный метасимвольный аргумент" вида "Stats<? extends Number> оb", т.е.:
		boolean sameAvg(Stats<? extends Number> оb) { //тут - любой тип подмножества Number
			if(average() == ob.average()) return true;
			return false;
		}
Таким образом, оператор extends налагает ограничение сверху на совпадение с метасимволом ?.
Ограничивать метасимвольный аргумент важно при создании обобщенного типа, оперирующего выделенной иерархией классов.
(Му - compil - по идее "?" может просто знать об extends, заданном в заголовке класса. Либо же, если возможность получить любой класс все же необходима, неплохо бы завести иной символ, например "??", который знает).




435

	

	